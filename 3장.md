---


---

<h1 id="콜백을-사용한-비동기-제어-흐름-패턴">3. 콜백을 사용한 비동기 제어 흐름 패턴</h1>
<p>비동기 코드를 작성하는 것은, 제어 흐름에서 어려움을 겪을 수 있다.<br>
비동기 코드로 인해 노드 내에서 명령문이 실행되는 순서를 예측하기 어려울 수 있다.<br>
일반적인 실수 중 하나는 콜백 지옥의 문제에 빠져서, 간단한 루틴조차 가독성을 떨어뜨리고 관리하기 힘들게 만들어 코드가 세로가 아닌 가로로 늘어나게 보이는 것이다.</p>
<p>어떻게 하면 콜백을 효율적으로 작성할 수 있을까?<br>
또 Async와 같은 제어흐름 라이브러리가 어떻게 문제를 단순화하며 코드를 간결하게 하는지 확인해보자.</p>
<h2 id="비동기-프로그래밍의-어려움">3.1 비동기 프로그래밍의 어려움</h2>
<p>자바스크립트에서 비동기 코드의 제어를 놓치는 것은 흔하게 일어난다.<br>
익명 함수의 클로저와 인플레이스 정의는 개발자가 프로그래밍을 원활하게 할 수 있게 한다.<br>
대부분의 경우 클로저를 만드는 것은 기능적으로 필요하지 않기 때문에, 비동기 프로그래밍에는 모듈화, 재사용성, 유지보수성같은 규칙을 지키는 것이 더욱 중요하다.</p>
<h3 id="간단한-웹-스파이더-만들기">간단한 웹 스파이더 만들기</h3>
<p>웹 URL을 입력으로 받아, 해당 URL의 내용을 로컬 파일로 다운로드 하는 콘솔용 어플리케이션인 웹 스파이더를 만들어 보자!</p>
<pre><code>"use strict";

const request = require('request');
const fs = require('fs');
const mkdirp = require('mkdirp');
const path = require('path');
const utilities = require('./utilities');

function spider(url, callback) {
  const filename = utilities.urlToFilename(url);
  fs.exists(filename, exists =&gt; {        //[1]
    if(!exists) {
      console.log(`Downloading ${url}`);
      request(url, (err, response, body) =&gt; {      //[2]
        if(err) {
          callback(err);
        } else {
          mkdirp(path.dirname(filename), err =&gt; {    //[3]
            if(err) {
              callback(err);
            } else {
              fs.writeFile(filename, body, err =&gt; { //[4]
                if(err) {
                  callback(err);
                } else {
                  callback(null, filename, true);
                }
              });
            }
          });
        }
      });
    } else {
      callback(null, filename, false);
    }
  });
}

spider(process.argv[2], (err, filename, downloaded) =&gt; {
  if(err) {
    console.log(err);
  } else if(downloaded){
    console.log(`Completed the download of "${filename}"`);
  } else {
    console.log(`"${filename}" was already downloaded`);
  }
});
</code></pre>
<p>request 모듈을 통해 입력받은 웹 페이지의 내용을 다운로드받는다.<br>
만약 이미 존재할 경우, 원래 존재했던 파일을 콜백으로 넘긴다.<br>
콜백은 아래에 (err, filename, downloaded) 를 인자로 받는 화살표 함수로 정의되어 있다.</p>
<h4 id="콜백-헬">콜백 헬</h4>
<p>우리가 만든 알고리즘이 정말 간단함에도 불구하고 결과 코드에 여러 수준의 인덴트가 적용되어 있어 가독성이 매우 떨어진다.<br>
많은 클로저와 내부 콜백 정의가 코드를 읽을 수 없고 관리할 수 없는 덩어리로 만드는 상황을 <strong>콜백 헬</strong>이라고 한다.</p>
<p>콜백 헬의 가독성 이외의 또 다른 문제는 각기 다른 스코프의 변수 이름의 중복이다.(err, err1, err2, err3…) 또한 활성 클로저가 참조하는 컨텍스트가 가비지 컬렉팅시 유지되므로, 적지 않은 메모리 누수가 발생할 수 있다.</p>
<h2 id="일반-javascript의-사용">3.2 일반 JavaScript의 사용</h2>
<p>일련의 비동기 코드를 작성하려면, 콜백 헬을 피할 뿐만 아니라 특정 패턴과 기법을 사용해야만 하는 경우들도 있다.<br>
외부 라이브러리를 사용하지 않고 간단한 자바스크립트만들 사용하여 가장 일반적인 제어 흐름 패턴을 구현하는 방법에 대해 알아보자.</p>
<h3 id="콜백-규칙">콜백 규칙</h3>
<ul>
<li>콜백을 사용할 때 함부로 클로저를 사용하지 않는다.</li>
<li>가능한 한 빨리 종료한다. 문맥에 따라 return, continue, break 등을 적절하게 활용한다.</li>
<li>콜백을 위해 명명된 함수를 생성하여 클로저 바깥에 배치하며 중간 결과를 인자로 전달한다.</li>
<li>코드를 작고 재사능 가능한 함수들로 모듈화한다.</li>
</ul>
<pre><code>클로저란?
내부함수과 외부함수의 지역변수에 접근할 수 있고, 
외부함수는 외부함수의 지역변수를 사용하는 
내부함수가 소멸될 때까지 소멸되지 않는 특성이다
</code></pre>
<h3 id="순차-실행">순차 실행</h3>
<p>순차 실행은 블로킹 API를 구현할 때는 간단하지만, CPS를 사용하여 구현할 경우 콜백 지옥의 주 원인이 된다.</p>
<h4 id="알려진-일련의-작업에-대한-순차-실행의-콜백-없애기">알려진 일련의 작업에 대한 순차 실행의 콜백 없애기</h4>
<pre><code>"use strict";

function asyncOperation(callback) {
  process.nextTick(callback);
}

function task1(callback) {
  asyncOperation(() =&gt; {
    task2(callback);
  });
}

function task2(callback) {
  asyncOperation(() =&gt; {
    task3(callback);
  });
}

function task3(callback) {
  asyncOperation(() =&gt; {
    callback(); //finally executes the callback
  });
}

task1(() =&gt; {
  //executed when task1, task2 and task3 are completed
  console.log('tasks 1, 2 and 3 executed');
});
</code></pre>
<p>비동기 작업을 실행할 때 항상 클로저를 사용할 필요는 없다.<br>
하드코딩을 통해 구현 가능하다.</p>
<h4 id="순차-반복">순차 반복</h4>
<p>순차 반복에서의 콜백을 줄이려면 동적 구축을 이용해야 한다.</p>
<pre><code>#패턴
function iterate(index){
	if(index === tasks.length){
		return finish();
	}
	const task = tasks[index];
	task(function(){
		iterate(index + 1);
	});
}

function finish(){
	//반복 작업이 완료된 후 처리
}

iterate(0);
</code></pre>
<pre><code>패턴 - 순차 반복자
iterator라는 함수를 작성하여 작업의 목록을 차례대로 실행한다.
iterator는 컬렉션에서 다음에 사용 가능한 태스크를 호출하고,
현재 태스크가 완료될 때 반복의 다음 단계를 호출하도록 한다.
</code></pre>
<h3 id="병렬-실행">병렬 실행</h3>
<p>작업들의 실행 순서가 중요하지 않고 모든 작업이 끝났을 때 알림을 받으면 되는 경우<br>
작업이 새로운 비동기 작업을 요구할 때, 이벤트 루프가 새로운 작업을 실행할 수 있도록 제어를 이벤트 루프로 되돌려준다.</p>
<pre><code>병렬 실행 패턴
const tasks = [ /* ... */ ];
let complete = 0;
tasks.forEach(task =&gt; {
	task(() =&gt; {
		if(++completed === tasks.length){
			finish();
		}
	});
});
function finish(){
	//모든 작업 완료
}
</code></pre>

