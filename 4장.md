---


---

<h1 id="es2015-이후-비동기식-프로그램의-제어-흐름-패턴">ES2015 이후 비동기식 프로그램의 제어 흐름 패턴</h1>
<p>콜백은 노드에서 비동기 프로그래밍을 위한 구성 요소지만, 수년동안 다른 대안들이 등장했고, 이 대안들은 비동기 코드를 보다 편하게 처리할 수 있는 방식으로 좀 더 세련된 방식들이다.<br>
<strong>프라미스</strong>, <strong>제너레이터</strong>, <strong>Async await</strong>등이 그것이다.<br>
이런 방식을 통해  비동기식 프로그램의 제어 흐름을 처리해보고, 각 방법들을 비교해보자.</p>
<h2 id="프라미스">4.1 프라미스</h2>
<p><strong>CPS(연속 전달 방식)</strong> , 즉 콜백을 통해 다음 작업을 전달하는 것이 비동기 코드를 작성하는 유일한 방식은 아니다. 다른 대안 중 하나인 프라미스가 있다.</p>
<h3 id="프라미스란-무엇인가">프라미스란 무엇인가?</h3>
<p>프라미스는 함수가 Promise라는 객체를 반환할 수 있도록 하는 <strong>추상화</strong>이다. Promise는 비동기 작업의 최종 결과를 나타낸다.<br>
프로미스의 용어로 <strong>대기중(Pending)</strong> 이란 아직 비동기 작업이 완료되지 않았단 것이고, 성공적으로 끝났을 때 이를 <strong>이행됨(fulfilled)</strong>, 작업이 실패하려 종료되는 것을 <strong>거부되었다(rejected)</strong> 고 한다. 프로미스가 이행되거나 거부되면 <strong>처리된(settled)</strong> 것으로 간주됩니다.</p>
<p>이행값이나 거부와 관련된 오류를 받으려면 다음과 같은 메소드를 사용한다.</p>
<pre><code>promise.then([onFulfilled], [onRejected])
</code></pre>
<p>위 코드에 onFulfilled() 는 최종적인 프라미스의 이행값을 받는 함수이고,<br>
또 다른 함수인 onRejected()는 거부 이유를 받게 된다. 위 함수 모두 선택 사항이다.<br>
이를 통해  코드를 다음과 같이 바꿀 수 있다.</p>
<pre><code>asyncOperation(arg, (err, result) =&gt; {
	if(err) {
		// 에러 처리
	}
	//결과 처리
});
</code></pre>
<pre><code>asyncOperation(arg)
	.then(result =&gt; {
		//결과 처리
	}, err =&gt; {
		//에러 처리
});
</code></pre>
<p>then() 메소드의 중요한 특성 중 하나는 동기식으로 다른 프로미스를 반환한다는 것이다. onFulifilled() 혹은 onRejected() 함수 중 하나가 x라는 값을 반환할 경우, then() 메소드가 반환하는 프로미스는 다음과 같다.</p>
<ul>
<li>x가 값이면 이행(filfill) 값 x 를 가지고 핸들러가 호출된다.</li>
<li>x가 프라미스거나 thenable(then() 메소드가 존재)인 경우, x를 가지고 이행된 값을 가지고 핸들러가 호출된다.</li>
<li>x가 프라미스거나 thenable인 경우, x의 거부 이유로 에러 핸들러가 호출된다.</li>
</ul>
<pre><code>thenable은 then()메소드를 가진 프라미스같은 객체이다.
사용중인 특정 프로미스와 다른 외부의 프로미스를 가리킬 때 사용된다.
</code></pre>
<p>위와 같은 특성을 사용해 비동기 작업을 통합할 수 있고, 작업을 순차 실행시킬 수 있다.</p>
<pre><code>asyncOperation(arg){
	.then(result1 =&gt; {
		//다른 프로미스를 변환
		return asyncOperantion(arg2):
	})
	.then(result2 =&gt;{
		//값을 반환
		return 'done';
	})
	.then(undefined, err =&gt; {
		//체인의 모든 에러를 여기서 처리함
	});
</code></pre>
<h3 id="표준-프로미스">표준 프로미스</h3>
<p>ES2015의 프로미스에 의해 제공되는 API 목록은 다음과 같다.</p>
<h4 id="생성자">생성자</h4>
<p>new Promise(function(resolve, reject) {})<br>
인자로 전달된 함수의 동작을 기반으로, 이행하거나 거부하는 새로운 프로미스를 만든다.<br>
함수에 전달되는 인자는 다음과 같은 기능을 한다.</p>
<ul>
<li>resolve : 값이 thenable일 경우 반환된 프로미스는 then메소드를 처리하고 마지막 상태를 취한다. thenable이 아닌 경우 프로미스는 주어진 값으로 이행된다.</li>
<li>reject(err) : err를 이유로 프로미스를 reject한다. err은 Error의 인스턴스이다.</li>
</ul>
<h4 id="promise-객체의-정적-메소드">Promise 객체의 정적 메소드</h4>
<ul>
<li>Promise.resolve(obj) : thenable이나 값으로 새로운 프로미스를 생성</li>
<li>Promise.reject(err): 주어진 이부로 거부되는 프로미스 객체 생성</li>
<li>Promise.all(iterable): 반복 가능한 모든 객체의 항목들을 이행시킨 후 모든 이행 값을 가지고 이행하는 프로미스 생성. 반복 가능한 객체 내 행복들은 프로미스, thenable 또는 그냥 값임</li>
<li>Promise.race(iterable): 반복 가능 객체 내 프로미스들 중 가장 먼저 이행되거나 거절된 결과를 가지고 이행 / 거부되는 프로미스 반환</li>
</ul>
<h4 id="프로미스-인스턴스의-메소드들">프로미스 인스턴스의 메소드들</h4>
<ul>
<li>promise.then(onfulfilled, onRejected): 프로미스의 필수 메소드</li>
<li>promise.catch( ‘’ ): 동일한 동작을 하는 간편 버전</li>
</ul>
<p>위 표준 프로미스를 통해, 순차 반복, 패턴이 있는 순차 반복, 제한 | 무제한 병렬 실행을 구현할 수 있다. 다음과 같은 패턴으로 구현한다</p>
<h4 id="순차-반복">순차 반복</h4>
<p>순차 반복 패턴은 루프를 이용하여 일련의 프로미스들을 동적으로 제작한다.</p>
<pre><code>function funcname(arg1, arg2, nesting){
	let promise = Promise.resolve();
	if(nesting === 0){//작업의 수 만큼의 반복을 마친 경우
		return promise; //프로미스 객체를 전달
	}
	...
	반복할 대상.forEach(arg1 =&gt; {
		promise = promise.then(() =&gt; 반복할함수(arg1,nesting -1));
	});
	return promise;
}
</code></pre>
<p>먼저 비어있는 프로미스를 정의한다.<br>
그런 다음, 체인 내에저 promise 변수의 then()을 호출하여 새로운 프로미스로 promise 변수를 갱신한다.</p>
<h4 id="순차-반복---패턴">순차 반복 - 패턴</h4>
<p>forEach()루프를 사용하는 대신 reduce() 함수를 사용하여 패턴을 간결하게 표현할 수 있다.</p>
<pre><code>let tasks = [ /*...*/ ]
let promise = tasks.reduce((prev, task) =&gt; {
	return prev.then(() =&gt; {
		return task();
	});
}, Promise.resolve(());
promise.then(() =&gt; {
	//모든 작업들이 완료됨
});
</code></pre>
<h3 id="병렬-실행">병렬 실행</h3>
<p>프로미스로 함수들을 비동기 병렬 실행하는 것은 매우 간단하다.<br>
그저 프로미스의 내장 메소드인 Promise.all()을 호출하는 것이다.</p>
<pre><code>function spiderLinks(currentUrl, body, nesting) {
	if(nesting === 0){
		return Promise.resolve();
	}
	const links = utilities.getPageLinks(currentUrl, body);
	const promies = links.map(link =&gt; spider(link, nesting -1));
	
	return Promise.all(promises);
}
</code></pre>
<p>elements.map 같이 반복이 가능한 루프에서 작업을 한번에 시작하는 것으로 구성한다. Promise.all은 모든 프로미스가 이행되었을 때 이행된다.</p>
<h4 id="제한된-병렬-실행">제한된 병렬 실행</h4>
<p>따로 동시 작업 수를 제한하는 고유한 방법을 제공하고 있지는 않지만, 앞에서 했던것처럼 그 다음 작업을 제공하는 함수를 수정함으로써 작업량을 제한할 수 있다.</p>
<pre><code>next(){
	while(this.running &lt; this.concurrency &amp;&amp; this.queue.length){
		const task = this.queue.shift();
		task().then(() =&gt; {
			this.running--;
			this.next();
		});
		this.running++;
	}
}
</code></pre>
<h3 id="공개-api로-콜백과-프로미스-노출하기">공개 API로 콜백과 프로미스 노출하기</h3>
<p>프로미스는 콜백 대신 사용될 수 있으며, 이는 코드의 가독성을 높인다.<br>
이렇게 프로미스는 많은 이점이 있지만, 정확하고 능숙하게 이것을 사용하기 위해서는 개발자는 중요한 많은 개념을 이해해야 한다.<br>
따라서 특정 경우에는 프로미스보다 콜백을 사용하는 것이 더 바람직할 수 있다.<br>
어느 것을 지향하는 API를 만들어야 할까?</p>
<p>쉬운 방법은, 콜백에만 기반만 간단한 API를 제공하고, 필요한 경우 공개된 기능을 프로미스화 할 수 있는 옵션을 제공하는 것이다.</p>
<p>두 번째 방법은, 콜백이 인자로 전달될 때마다 함수는 평범하게 작동해서 완료되거나 실패할 때 콜백을 실행한다. 인자로 콜백이 전달되지 않으면 즉시 Promise 객체를 반환한다.<br>
예시는 아래와 같다.</p>
<pre><code>module.exports = function asyncDivision(dividend, divisor, cb){
	return new Promise((resolve, reject) =&gt; {
		
		process.nextTick(()=&gt;{
			const result = dividend / divisor;
			if(isNaN(result) || !Number.isFinite(result)){
				const error = new Error('Invalid operands');
				if(cb){ cb(error); } //콜백이 인자로 전달된 경우 에러를 전달
				return reject(error);
			}
			if(cb){ cb(null, result); }
			resolve(result);
		});
		
	});
};
</code></pre>
<p>먼저 프로미스를 만든다. 결과를 계산한 후에 콜백이 존재하면 콜백에도 결과를 전달하고, 콜백이 없으면 프로미스만 결정된다.</p>
<p>아래와 같이 사용한다.</p>
<pre><code>#콜백 사용
asyncDivision(10, 2, (error,result) =&gt; {
	if(error){
		return console.error(error);
	}
	console.log(result);
});

//프로미스 사용
asyncDivision(22, 11)
	.then(result =&gt; console.log(result))
	.catch(error =&gt; console.error(error));
</code></pre>

