---


---

<h1 id="장-모듈-연결">7장 모듈 연결</h1>
<p>Node.js의 모듈 시스템은 코드를 자체적인 독립된 유닛으로 구성할 수 있는 네이티브적인 방법이 부족한 자바스크립트 언어와의 격차를 메워 준다.<br>
가장 큰 장점 중 하나는, 간단하고 강력한 접근 방식은 require()를 사용하여 이들 모듈들을 서로 연결할 수 있다는 것이다.</p>
<p>노드 개발자들이 자주 접하는 질문 중 하나는<br>
“모듈 X의 인스턴스를 모듈 Y로 전달하는 가장 좋은 방법은 무엇입니까?”<br>
다.<br>
그 만큼 노드에서 모듈을 연결하는 방법은 Node.js의 디자인패턴 중 중요한 질문이라고 할 수 있다.<br>
따라서 사람들은 모듈들을 서로 연결하는 더 친숙한 방법을 찾기 위해 싱글톤, 종속성 삽입까지 사용하기도 한다.<br>
<strong>모듈 연결(wiring)</strong> 기술이 Node.js에서 가장 논란의 여지가 있으며 독창적인 주제 중 하나라는 것은 놀라운 일이 아니다.</p>
<p>이 영역에 영향을 미치는 많은 이론이 있지만, 명확한 정답은 없다.<br>
실제로 모든 접근법에는 장단점이 있으며, 종종 동일한 APP에서 여러 가지 접근법을 사용하거나 다른 이름으로 변경되거나 커스터마이징 되어 사용된다.</p>
<p>이 장에서는 모듈 연결에 대한 접근법을 분석하고, 장단점을 강조한다.<br>
또한 단순성, 재사용성 및 확장성의 기준에 따라 합리적인 선택과 혼합을 할 수 있도록 한다.<br>
가장 중요한 패턴들은 아래와 같다.</p>
<ul>
<li>하드코딩된 종속성</li>
<li>의존성 주입(Dependency Injection)</li>
<li>서비스 로케이터</li>
<li>의존성 주입 컨테이너</li>
</ul>
<p>그런 다음 밀접하게 관련된 문제로 플러그인을 연결하는 방법을 본다.<br>
플러그인이 별도의 패키지로 배포되는 경우 App의 내용에 따라 조금씩 차이가 있으며, 자체적인 문제점이 존재한다.<br>
플러그인이 가능한 구조를 만드는 주요한 기술을 먼저 배우고, 이 플러그인을 메인 App의 흐름에 통합하는 방법을 살펴보자.</p>
<h1 id="모듈과-의존성">7.1 모듈과 의존성</h1>
<p>모든 최신 App은 여러 컴포넌트들을 결합한 결과이며, 어플리케이션이 커짐에 따라 이러한 컴포넌트를을 연결하는 방식이 승패 요건이 된다.<br>
확장성과 같은 기술적 측면과 관련된 문제일 뿐만 아니라 시스템을 이해하는 방식에 대한 인식도 있다.<br>
얽힌 <strong>종속성 그래프</strong>는 골칫거리가 되며, 프로젝트의 <strong>기술적 부채</strong>가 된다.</p>
<p>최악의 경우 컴포넌트들이 너무 밀접하게 연결되어 있어, 리팩토링이나 어플리케이션 전체 부분을 완전히 다시 작성하지 않고는 기능을 추가하거나 변경할 수 없게 된다. 따라서, 처음부터 좋은 균형을 찾는 것이 큰 차이를 만들 수 있다.</p>
<p>노드는 어플리케이션의 컴포넌트를 구성하고 묶는 유용한 도구들을 제공하는데, 이 모듈이 CommonJS 모듈 시스템(module system)이다. 그러나 모듈 시스템만으로는 성공을 보장할 수 없다. 다른 한편으로는 클라이언트 모듈과 종속성 사이에 간접적인 수준의 참조를 추가하여 적절하게 사용하지 않으면, 더 엄격한 결합을 만들게 될 수 있다.</p>
<h2 id="node.js의-가장-일반적인-종속성">7.1.1 Node.js의 가장 일반적인 종속성</h2>
<p>소프트웨어 아키텍처에서는 컴포넌트의 동작이나 구조에 영향을 미치는 엔티티, 상태 또는 데이터 형식을 <strong>종속성</strong>으로 간주할 수 있다.<br>
예를 들어, 어떤 컴포넌트가 다른 컴포넌트에서 제공하는 서비스를 사용하거나, 시스템의 특정 상태에 의존하거나, 다른 컴포넌트와 정보를 교환하기 위해 통신 프로토콜을 구현하는 등을 이유로 들 수 있다.<br>
종속성의 개념은 광범위하며, 때로는 평가하기도 어렵다.</p>
<p>하지만 Node.js에서는 가장 일반적이며 쉽게 식별할 수 있는 필수 유형의 종속성을 바로 식별해낼 수 있다.<br>
모듈(Module)은 코드를 구조화하는 데 필요한 기본적인 메커니즘이다. 어플리케이션의 다양한 요소들을 <strong>그룹화</strong>하는데 제대로 사용한다면, 이점이 많다. 실제 모듈의 속성은 다음과 같이 요약할 수 있다.</p>
<ul>
<li>모듈은 보다 집중적이기 때문에, 더 가독성이 높고 이해하기 쉬움</li>
<li>별도의 파일로 표현하기 때문에 쉽게 식별할 수 있음</li>
<li>모듈을 다른 App보다 쉽게 재사용할 수 있음.</li>
</ul>
<p>모듈은 정보 은닉을 수행하는 완벽한 수준의 세분화된 단위를 나타내며(Module.exports) 컴포넌트의 공개 인터페이스만을 노출하고 나머지는 은닉하는 효과적인 메커니즘을 제공한다.<br>
그러나 단순히 어플리케이션이나 라이브러리의 기능을 여러 모듈에 분산시키는 것만으로는 성공적인 디자인이라 할 수 없다. 잘못된 사용 중 한 가지는 독특한 모놀리식(monolithic) 개체를 만들어 내는 것이며, 그 상태에서 모듈을 제거하거나 교체하는 것이 아키텍처의 대부분을 뒤흔들게 된다.<br>
코드를 모듈로 구성하는 방식과 모듈을 서로 연결하는 방식이 전략적인 역할을 하며, 소프트웨어 설계의 모든 문제와 마찬가지로 여러 가지 평가 항목들 사이에서 <strong>적절한 균형</strong>을 찾아야 한다.</p>
<h2 id="응집력과-결합력">7.1.2 응집력과 결합력</h2>
<p>모듈을 만들 때 가장 중요한 두 가지 특성은 <strong>응집력과 결합력이 균형</strong>을 이루는 것이다.<br>
이것들은 소프트웨어 아키텍처에서 모든 유형의 컴포넌트 또는 하위 시스템에 적용될 수 있으므로 노드 모듈을 구축할 때 지침으로 사용할 수 있다.</p>
<p>이 두 속성은 다음과 같이 정의할 수 있다.</p>
<h4 id="응집력cohesion">응집력(Cohesion)</h4>
<p>컴포넌트 기능 간의 <strong>상관관계</strong>에 대한 측도이다.<br>
예를 들어 단 한가지의 작멉한 하는 모듈은, 모듈의 모든 부분이 그 하나의 단일 업무에서만 역할을 할 경우 높은 응집력을 가진다고 할 수 있다. <em>saveProduct(), saveInvoice(), saveUser()</em> 등과 같이 모든 유형의 객체를 데이터베이스에 저장하는 함수를 가진 모듈은 낮은 응집력을 가진다.</p>
<h4 id="결합력coupling">결합력(Coupling)</h4>
<p>구성 요소가 시스템이나 다른 구성 요서에 얼마나 <strong>의존</strong>하는지에 대한 측도이다.<br>
예를 들어, 모듈이 다른 모듈의 데이터를 직접 읽거나 수정하면, 결합력이 높은 모듈이다.<br>
또한 전역이나 공유된 상태를 통해 상호작용하는 모듈들은 밀접한 결합이다.<br>
반면에 매개 변수 전달을 통해서만 두 모듈이 통신한다면 느슨한 결합이라고 할 수 있다.</p>
<p>바람직한 시나리오는 <strong>높은 응집력</strong>과<strong>느슨한 결합</strong>을 가지는 것이다.<br>
이는 일반적으로 재사용 가능하고 확장 가능한 모듈을 뜻한다.</p>
<p><strong>왠만하면 매개변수만 가지고 자기 안에서 끝내는 것을 목표로 하자!</strong><br>
<strong>=&gt; 모듈 단위가 작아질 수 밖에 없음</strong></p>
<h2 id="상태-저장stateful-모듈">7.1.3 상태 저장(Stateful) 모듈</h2>
<p>자바스크립트에서는 모든 것이 하나의 <strong>객체</strong>이다. 인터페이스나 클래스와 같은 추상적이 개념이 없다.<br>
동적 타이핑은 이미 <strong>인터페이스</strong>(또는 <strong>정책</strong>, 패턴)를 <strong>구현</strong>(또는 <strong>세부사항</strong>)에서 분리하는 자연스러운 매커니즘을 제공한다. 그것이 6장에서 본 디자인 패턴 중 일부가 기존 패턴과 비교해서 매우 다르면서 단순해 보이는 이유 중 하나이다.</p>
<p>그러나 자바스크립트에서는 인터페이스와 구현을 분리할 때 작은 문제점을 가지고 있다.<br>
이미 간단하게 노드 모듈 시스템을 사용함으로써 특정 구현체와의 하드코드된 관계를 볼 수 있었다.<br>
정상적인 상태에서는 이 문제가 발생하지 않지만, require()를 사용하여 DB핸들, HTTP 서버 인스턴스, 서비스 인스턴스 같은 상태 저장(stateful) 인스턴스를 외부에 익스포트하는 모듈을 로드하거나 상태 저장이 아닌(stateless) 일반 객체를 익스포트하는 모듈을 로드할 경우, 실제 싱글톤과 매우 유사한 것을 참조하게 됨으로써 주의사항과 장단점을 얻게 된다.</p>
<h3 id="node.js의-싱글톤-패턴">Node.js의 싱글톤 패턴</h3>
<p>Node를 처음 사용하는 사람들은 대부분의 경우 어플리케이션의 다양한 모듈 간에 <strong>단일한 인스턴스</strong>를 공유하기 위한 방법으로 싱클톤 패턴을 선호하게 되고, 어떻게 싱글톤 패턴을 올바르게 구현할 수 있는지를 혼란스러워 한다. 그러나 노드의 대답은 우리의 생각보다 쉽다. 단순히 module.exports를 사용하여 인스턴스를 내보내는 것만으로 이미 싱글톤(Singleton)패턴과 비슷한 것을 얻을 수 있다.</p>
<p>예를 들어 다음과 같은 코드를 생각해 보자.</p>
<pre><code>module.exports = new Database('my-app-db');
</code></pre>
<p>단순히 DB에서 새로운 인스턴스를 내보내는 것만으로도 현재 패키지 내에서 이미 db모듈의 인스턴스가 <strong>하나만 있다고 가정할 수 있다.</strong> 우리가 이미 알다시피 Node.js는 require()의 첫 번째 호출 이후에 모듈을 <strong>캐시</strong>할 것이고, 이후의 호출에서 다시 실행하지 않고 <strong>캐시된 인스턴스를 반환</strong>하기 때문에 가능하다.</p>
<pre><code>const db = require('./db');
</code></pre>
<p>단순히 다음과 같은 코드로 앞에서 정의한 db모듈의 공유 인스턴스를 가져올 수 있다.</p>
<p>이 과정에는 유의사항이 있다. 모듈은 전체 경로를 검색 키로 사용하여 캐시되므로, <strong>현재 패키지 내에서만 싱글톤이 보장된다.</strong><br>
각 패키지가 자신의 node_modules 디렉토리 내에 일련의 자신만의 종속성들을 가질 수 있으므로, 다음과 같은 상황이 발생할 수 있다.</p>
<pre><code>#package.json
{
	"name": "mydb"
	"main": "db.js"
}
</code></pre>
<p>아래과 같은 종속성 트리를 생각해보자.</p>
<pre><code>app/
	ㄴnode_modules
		ㄴpackageA
			ㄴnode_modules
				ㄴmydb
		ㄴpackageB
			ㄴnode_modules
				ㄴmydb
</code></pre>
<p>packageA와 packageB는 모두 mydb 패키지에 종속성을 가지고 있다.<br>
app패키지는 packageA와 packageB에 종속성을 가진다.<br>
실제로 packageA와 packageB는 다음과 같은 명령을 사용해 db인스턴스를 로드할 것이다.</p>
<pre><code>const db = require(mydb);
</code></pre>
<p>이렇게 하면, 같은 mydb지만 패키지에 따라 다른 인스턴스로 해석되기 때문에 packageA와 packageB는 실제로 싱글톤처럼 보이는 두 개의 서로 다른 인스턴스를 로드한다.</p>
<p>이 시점에서 우리는 <code>global.db = new Database('my-app-db');</code>와 같이 선언하지 않는 이상,<br>
앞서 설명된 패턴은 노드 내에 존재하지 않는다고 할 수 있다.</p>
<p>이렇게 하면 인스턴스가 유일한 패키지가 될 뿐 아니라, 비단 한 패키지 뿐만 아니라 전체 어플리케이션에 공유될 것이다. 이것은 <strong>절대 추천되는 상황이 아니다.</strong> 또한 굳이 이렇게 할 필요도 없다.</p>
<h1 id="모듈-연결-패턴">7.2 모듈 연결 패턴</h1>
<p>가중 중요한 유형의 종속성인 상태 저장(Stateful)과 인스턴스의 연결(wiring)에 대해 살펴보자.</p>
<h2 id="하드코딩된-종속성">7.2.1 하드코딩된 종속성</h2>
<p>하드코딩된 의존성을 가지는 두 모듈 간의 일반적인 관계를 살펴보자.<br>
Node.js에서 이것은 클라이언트 모듈이 require()를 사용하여 다른 모둘을 명시적으로 로드할 때 발생한다.<br>
모듈 종속성을 설정하는 이 방법은 간단하고 효과적이지만, 모듈의 재사용을 제한하기 때문에 상태 저장(Stateful) 인스턴스와의 종속성을 하드코딩할 때는 저 주의를 기울여야 한다.</p>
<h3 id="하드코드된-종속성을-사용한-인증-서버-구축">하드코드된 종속성을 사용한 인증 서버 구축</h3>
<pre><code>AuthController -&gt; AuthService -&gt; DB
</code></pre>
<p>위와 같은 구조는 계층화된 아키텍쳐의 전형적인 예이다.<br>
AuthController는 클라이언트로부터 입력을 받아, 요청으로부터 로그인 정보를 추출하고 예비 검증을 수행한다.<br>
그런 다음 AuthService를 사용하여 제공된 자격 증명을 이 데이터베이스에 저장된 정보와 일치하는지 확인한다.<br>
이것은 데이터베이스와 통신하는 수단으로, db모듈을 사용하여 특정 쿼리문을 실행함으로써 수행된다.<br>
이 세 가지 컴포넌트가 함께 연결되는 망식은 재사용성, 테스트 편리성 및 유지관리 가능성 수준을 결정한다.</p>
<p>이러한 구성 요소들을 연결하는 가장 간편한 방법은 AuthService에서 db 모듈을 require한 다음, AuthController에서 AuthService를 require하는 것이다. 이것이 우리가 말하는 <strong>하드코딩된 종속성</strong>이다.</p>
<p>JWT를 통해 사용자를 인증하는 시스템을 구현해 보자.</p>
<pre><code>JWT(Json Web Token은 당사자 간의 클레임을 표현하고 공유하기 위한 형식이다.
단일 페이지 App 및 Cross-Origin Resource Shared(CORS)가 폭발적으로 증가함에 따라,
쿠키 기반 인증보다 유연한 대안으로 인기가 높아지고 있다.
</code></pre>
<blockquote>
<p>lib/db.js<br>
lib/authService.js<br>
lib/authController.js<br>
jwtTest.js<br>
populate_db.js</p>
<p>실행방법<br>
curl -X POST -d “{”“username”": ““alice””, ““password””:"“secret”"}" <a href="http://localhost:3000/login">http://localhost:3000/login</a> -H “Content-Type: application/json”<br>
curl -X GET -H “Accept: application/json” <a href="http://localhost:3000/checkToken?token=">http://localhost:3000/checkToken?token=</a>&lt;토큰&gt;</p>
</blockquote>
<h4 id="db-모듈">db 모듈</h4>
<p>levelUp 데이터베이스 인스턴스를 export.<br>
데이터베이스 핸들 자체를 내보내며, 상태 저장(stateful)인스턴스이다. 따라서 단일 개체를 생성한다.</p>
<h4 id="authservice-모듈">authService 모듈</h4>
<p>사용자 이름/비밀번호 쌍을 검사하고 토큰을 발급하는 login메소드와 토큰의 유효성을 확인하는 checkToken메소드를 가지고 있다.<br>
<code>const db = require('./db');</code><br>
여기서 앞에서 코딩한db모듈을 가져오는 하드코딩된 종속성을 보여준다. 우리는 이 모듈에서 직접적으로 db모듈의 인스턴스를 다루지 않는다.</p>
<p>우리가 만든 모든 인스턴스들은 간단하게 동작하지만, 특정 db인스턴스에 대한 종속성을 하드코딩했기 때문에 코드를 건드리지 않고는 authService를 다른 데이터베이스 인스턴스와 함께 재사용할 수 없다.</p>
<h4 id="authcontroller-모듈">authController 모듈</h4>
<p>상태 유지 모듈 authService에 대한 종속성을 하드코딩한다.<br>
authServiec 모듈은 db모듈에 직접 의존하기 때문에 포함 관계로 인한 이행성 때문에 상태 유지 모듈이 된다. 이런 식으로 하드코딩된 종속성이 전체 App 전반에 쉽게 전파될 수 있다.<br>
<strong>이행성</strong>이란 authService 모듈 자체가 특정 db 인스턴스에 <strong>간접적으로 연결됨</strong>을 의미한다.</p>
<h3 id="하드코딩된-종속성의-장단점">하드코딩된 종속성의 장단점</h3>
<p>모듈 시스템의 모든 기능을 활용하여 Node.js에서 어플리케이션의 다양한 컴포넌트 간에 종속성을 관리하고 모듈을 연결하는 일반적인 방법을 확인하여다.<br>
우리는 모듈에서 상태 저장(Stateful) 인스턴스를 내보내서(export) 호출자에서 생명 주기를 관리하게 한 다음, 그것들을 어플리케이션의 다른 부분에서 직접 require했다. 그 결과 직관적인 구성으로 이해하기 쉽고 디버깅하기 쉬우며, 각 모듈은 외부에서 개입하지 않아도 초기화되고 연결된다.</p>
<p>그러나 상태 유지 인스턴스에 대한 종속성을 하드코딩하면 모듈을 다른 인스턴스에 연결하는 가능성이 제한되어 재사용성이 낮아지며 단위 테스트가 어려워진다.<br>
예를 들어, 다른 DB 인스턴스와 함께 authService모듈을 재사용하는 것은 거의 불가능하다.<br>
마찬가지로 authService를 독립적으로 테스트하는것도 어렵다.</p>
<p>마지막으로 하드코딩된 종속성 사용의 단점은 대부분 <strong>상태 유지(stateful) 인스턴스와 관련되어 있다.</strong> 이것은 우리가 require()를 사용하여 상태가 없는 모듈(팩토리, 생성자, 일련의 상태 비저장 함수)를 로드하는 경우에는 동일한 종류의 문제가 발생하지 않는다는 것을 의미한다.<br>
다시 말해 특정 구현과의 긴밀한 결합은 여전히 존재하지만, Node.js에는 특정 상태와의 결합성(coupling)을 발생시키지 않으므로 일반적으로 컴포넌트의 재사용성에 영향을 주지 않는다.</p>
<h2 id="의존성-주입">7.2 의존성 주입</h2>
<p>DI(Dependency Injection) 패턴은 소프트웨어 설계에서 가장 잘못 이해되고 있는 개념 중 하나다.<br>
많은 사람들은 Spring(Java 및 C#) 또는 Pimple과 같은 프레임워크 및 DI컨테이너와 용어를 일치시켜 생각하지만, 실제로는 훨씬 간단한 개념이다.<br>
DI패턴의 주요 아이디어는 <strong>컴포넌트의 종속성들을 외부 개체에 의해 입력으로 제공하는 것</strong>이다.<br>
이러한 개체는 시스템의 모든 모듈의 연결을 중앙 집중화하는 클라이언트 컴포넌트 또는 전역 컨테이너일 수 있다. 이 접근법의 가장 큰 장점은, 특히 상태 저장 인스턴스 모듈에 대해 디커플링이 향상된다는 것이다.  DI를 사용하여 각 종속성들은 모듈에 하드코딩되지 않고, 외부에서 수신된다. 즉, 모듈이 어떤 종속성이든 사용하도록 설정할 수 있으므로, 다른  컨텍스트에서 재사용할 수 있다.</p>
<p>이 패턴의 설명을 위에 jwt를 리팩토링하고 DI로 모듈을 연결해 보자.</p>
<h3 id="di를-사용한-인증-서버-리팩토링">DI를 사용한 인증 서버 리팩토링</h3>
<p>상태 저장 인스턴스에 대한 종속성을 하드코딩하는 대신에, 일련의 종속성을 인수로 취하는 팩토리를 생성함으로써 DI를 사용할 수 있다.</p>
<blockquote>
<p>DIlib/db.js<br>
DIlib/authService.js<br>
DIlib/authController.js<br>
DIapp.js</p>
</blockquote>
<h4 id="db.js">db.js</h4>
<p>db 모듈을 팩토리로 변경한다. 결과적으로 원하는 만큼의 데이터베이스를 만들 수 있게 되었으며, 이는 전체 모듈이 이제 재사용 가능하며 상태 비저장(stateless)임을 뜻한다.</p>
<h4 id="authservice.js">authService.js</h4>
<p>authService 모듈 또한, db와 토큰 비밀번호를 입력받아 서비스를 생성하는 팩토리로 생성함으로써, 상태 비저장(stateless)가 되었다. 더 이상 특정한 인스턴스를 익스포트하는 것이 아니라, 단순히 팩토리를 익스포트한다. 가장 중요한 사항은 이전의 하트코딩된 db종속성을 제거하고 팩토리 함수의 인수로 <strong>주입</strong>할 수 있다는 것이다.</p>
<h4 id="authcontroller.js">authController.js</h4>
<p>authController 모듈에도 이제 하드코딩된 의존성이 없어졌다. 심지어는 상태 비저장(stateless)도 없다. 유일한 의존성인 authService모듈은 호출하는 순간 팩토리에 입력으로 주어진다.</p>
<h4 id="diapp.js">DIapp.js</h4>
<p>수정한 대로 팩토리를 통해 전달받고, 또 전달받은 모듈 주입시킨다.</p>
<p>우선 서비스의 팩토리들을 로드한다. 이 시점에서 그들은 여전히 상태 비저장(stateless)객체이다.<br>
다음으로 필요한 종속성들을 주입하여 각 서비스를 인스턴스화한다.<br>
마지막으로 authController모듈의 라우트들을 익스프레스 서버에 등록록한다.</p>
<h3 id="다양한-유형의-di">다양한 유형의 DI</h3>
<p>방금 예시에서 DI의 한 유형인 <strong>팩토리 인젝션</strong>을 보았다.<br>
이외에 DI패턴으로는 다음과 같은 DI가 있다.</p>
<h4 id="생성자-인젝션">생성자 인젝션</h4>
<p>이 유형의 DI에서는 의존성이 생성 순간에 생성자에게 전달된다.</p>
<pre><code>const service = new Service(dependencyA, dependencyB);
</code></pre>
<h4 id="속성-인젝션">속성 인젝션</h4>
<p>종속성이 생성된 객체에 아래와 같이 첨부한다.</p>
<pre><code>const service = new Service();//팩토리 사용 가능
service.dependencyA = anInstanceOfDependencyA;
</code></pre>
<p>속성 인젝션은 객체와 종속성이 서로 연결되지 않기 때문에, 객체가 일관성 없는 상태로 생성된다는 것을 의미하므로 덜 강력하다. 하지만 종속성 간의 순환이 있을 때는 유용하다.<br>
예를 들어 팩토리 또는 생성자 주입을 사용하는 A와 B 두 가지 컴포넌트가 있는데, 두 컴포넌트가 서로에게 종속성이 있는 경우 둘 중 하나는 인스턴스화할 수 없다.<br>
왜냐면 둘 다 생성되기 위해서는 상대 컴포넌트가 요구되기 때문이다.</p>
<pre><code>function Afactory(b){
	return {
		foo: function(){
			b.say();
		},
		what: function(){
			return 'Hello!';
		}
	}
}
function Bfactroy(a){
	return {
		a: a,
		say: () =&gt; {
			console.log('I say: a.what);
		}
	}
}
</code></pre>
<p>앞의 소스같은 경우 두 팩토리 간의 종속성 교차 생태를 속성 인젝션을 통해 해결할 수 있다.<br>
아래와 같이 불완전한 B 인스턴스를 먼저 생성한 다음, A를 생성하는데 사용한다.<br>
마지막으로 상대 속성을 통해 A에 B를 삽입한다.</p>
<pre><code>const b = Bfactory(null);
const a = Afactory(b);
a.b = b;
</code></pre>
<h3 id="di의-찬반론">DI의 찬반론</h3>
<p>DI를 사용한 인증 서버 예제에서 모듈을 특정 종속성 인스턴스로부터 분리할 수 있었다.<br>
그 결과 우리는 최소한의 노력으로 각 모듈을 재사용할 수 있게 되었다.<br>
DI패턴을 사용한 모듈을 테스트하는 작업 또한 간단하게 할 수 있다.</p>
<p>또 다른 중요한 점은, 의존 관계를 연결하는 책임을 아키텍쳐의 맨 아래에서 맨 위로 옮겼다는 점이다. 상위 수준의 컴포넌트(App)이 하위 수준의 컴포넌트(db)보다 재사용성이 낮고, 컴포넌트가 더 많이 구체화된다는 것에 기반한다.</p>
<p>이 가정을 바탕으로, 우리는 상위 수준 컴포넌트가 그들의 낮은 수준의 종속성에 관여하지 않는다는 어플리케이션 아키텍쳐를 보는 전통적인 방식을 뒤집을 수 있다는 것을 알 수 있다.<br>
하위 수준의 컴포넌트는 인터페이스에서만 의존하므로, 종속성 구현을 정의하는 책임은 상위 수준 컴포넌트에 부여된다. 실제, 우리의 인증 서버에서는 모든 의존성이 가장 위의 컴포넌트, 즉 재사용성이 낮고 결합 측면에서 가장 소모적인 app모듈에서 인스턴스화되고 결합된다.</p>
<p>그러나 디커플링 및 재사용성 측면에서 이러만 모든 장점은 <strong>비용을 지불해야 한다.</strong><br>
일반적으로 코딩을 할 때 의존성을 해결할 수 없으면, 시스템의 다양한 컴포넌트들 간의 관계를 이해하기가 더욱 어려워진다. 또한 앱 모둘의 모든 종속성을 인스턴스화하는 방식을 살펴보면 특정 순서를 따라야 한다는 것을 알 수 있다. 사실상 우리는 전체 어플리케이션의 종속성 그래프를 수동으로 구축하였다. 이것은 연결해야 할 모듈 수가 많아질 때 관리하기 어려워질 수 있다.</p>
<p>이 문제에 대한 실행 가능한 솔루션은, 여러 컴포넌트들 간의 종속성 소유권을 <strong>분할</strong>하는 것이다. 이렇게 하면 각 컴포넌트가 특정 종속성 하위 그래프만 담당하므로, 기하급수적으로 증가하는 종속성을 관리하는 복잡함을 줄일 수 있다.<br>
즉, 어플리케이션의 모든 부분에 DI를 적용하는 대신, 필요할 때 부분적으로 DI를 사용하는 방법을 선택할 수도 있다.</p>
<p>또한, 복잡한 아키텍쳐에서 모둘들의 연결을 단순화하는 또 다른 해결책은 어플리케이션의 모든 종속성을 인스턴스화하고 연결해주는 것을 독점적으로 책임지는 컴포넌트인 <strong>DI 컨테이너</strong>를 사용하는 것이다.</p>
<p>DI를 사용하면 모듈의 복잡성과 장황함이 증가하지만, 이전에 보았듯 이렇게 하는데는 여러 가지 이유가 있다. 단순성과 재사용성 사이의 <strong>균형</strong>에 따라 알맞은 접근법을 선택하는 것이 중요하다.</p>

