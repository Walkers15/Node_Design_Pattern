---


---

<h1 id="장-모듈-연결">7장 모듈 연결</h1>
<p>Node.js의 모듈 시스템은 코드를 자체적인 독립된 유닛으로 구성할 수 있는 네이티브적인 방법이 부족한 자바스크립트 언어와의 격차를 메워 준다.<br>
가장 큰 장점 중 하나는, 간단하고 강력한 접근 방식은 require()를 사용하여 이들 모듈들을 서로 연결할 수 있다는 것이다.</p>
<p>노드 개발자들이 자주 접하는 질문 중 하나는<br>
“모듈 X의 인스턴스를 모듈 Y로 전달하는 가장 좋은 방법은 무엇입니까?”<br>
다.<br>
그 만큼 노드에서 모듈을 연결하는 방법은 Node.js의 디자인패턴 중 중요한 질문이라고 할 수 있다.<br>
따라서 사람들은 모듈들을 서로 연결하는 더 친숙한 방법을 찾기 위해 싱글톤, 종속성 삽입까지 사용하기도 한다.<br>
<strong>모듈 연결(wiring)</strong> 기술이 Node.js에서 가장 논란의 여지가 있으며 독창적인 주제 중 하나라는 것은 놀라운 일이 아니다.</p>
<p>이 영역에 영향을 미치는 많은 이론이 있지만, 명확한 정답은 없다.<br>
실제로 모든 접근법에는 장단점이 있으며, 종종 동일한 APP에서 여러 가지 접근법을 사용하거나 다른 이름으로 변경되거나 커스터마이징 되어 사용된다.</p>
<p>이 장에서는 모듈 연결에 대한 접근법을 분석하고, 장단점을 강조한다.<br>
또한 단순성, 재사용성 및 확장성의 기준에 따라 합리적인 선택과 혼합을 할 수 있도록 한다.<br>
가장 중요한 패턴들은 아래와 같다.</p>
<ul>
<li>하드코딩된 종속성</li>
<li>의존성 주입(Dependency Injection)</li>
<li>서비스 로케이터</li>
<li>의존성 주입 컨테이너</li>
</ul>
<p>그런 다음 밀접하게 관련된 문제로 플러그인을 연결하는 방법을 본다.<br>
플러그인이 별도의 패키지로 배포되는 경우 App의 내용에 따라 조금씩 차이가 있으며, 자체적인 문제점이 존재한다.<br>
플러그인이 가능한 구조를 만드는 주요한 기술을 먼저 배우고, 이 플러그인을 메인 App의 흐름에 통합하는 방법을 살펴보자.</p>
<h1 id="모듈과-의존성">7.1 모듈과 의존성</h1>
<p>모든 최신 App은 여러 컴포넌트들을 결합한 결과이며, 어플리케이션이 커짐에 따라 이러한 컴포넌트를을 연결하는 방식이 승패 요건이 된다.<br>
확장성과 같은 기술적 측면과 관련된 문제일 뿐만 아니라 시스템을 이해하는 방식에 대한 인식도 있다.<br>
얽힌 <strong>종속성 그래프</strong>는 골칫거리가 되며, 프로젝트의 <strong>기술적 부채</strong>가 된다.</p>
<p>최악의 경우 컴포넌트들이 너무 밀접하게 연결되어 있어, 리팩토링이나 어플리케이션 전체 부분을 완전히 다시 작성하지 않고는 기능을 추가하거나 변경할 수 없게 된다. 따라서, 처음부터 좋은 균형을 찾는 것이 큰 차이를 만들 수 있다.</p>
<p>노드는 어플리케이션의 컴포넌트를 구성하고 묶는 유용한 도구들을 제공하는데, 이 모듈이 CommonJS 모듈 시스템(module system)이다. 그러나 모듈 시스템만으로는 성공을 보장할 수 없다. 다른 한편으로는 클라이언트 모듈과 종속성 사이에 간접적인 수준의 참조를 추가하여 적절하게 사용하지 않으면, 더 엄격한 결합을 만들게 될 수 있다.</p>
<h2 id="node.js의-가장-일반적인-종속성">7.1.1 Node.js의 가장 일반적인 종속성</h2>
<p>소프트웨어 아키텍처에서는 컴포넌트의 동작이나 구조에 영향을 미치는 엔티티, 상태 또는 데이터 형식을 <strong>종속성</strong>으로 간주할 수 있다.<br>
예를 들어, 어떤 컴포넌트가 다른 컴포넌트에서 제공하는 서비스를 사용하거나, 시스템의 특정 상태에 의존하거나, 다른 컴포넌트와 정보를 교환하기 위해 통신 프로토콜을 구현하는 등을 이유로 들 수 있다.<br>
종속성의 개념은 광범위하며, 때로는 평가하기도 어렵다.</p>
<p>하지만 Node.js에서는 가장 일반적이며 쉽게 식별할 수 있는 필수 유형의 종속성을 바로 식별해낼 수 있다.<br>
모듈(Module)은 코드를 구조화하는 데 필요한 기본적인 메커니즘이다. 어플리케이션의 다양한 요소들을 <strong>그룹화</strong>하는데 제대로 사용한다면, 이점이 많다. 실제 모듈의 속성은 다음과 같이 요약할 수 있다.</p>
<ul>
<li>모듈은 보다 집중적이기 때문에, 더 가독성이 높고 이해하기 쉬움</li>
<li>별도의 파일로 표현하기 때문에 쉽게 식별할 수 있음</li>
<li>모듈을 다른 App보다 쉽게 재사용할 수 있음.</li>
</ul>
<p>모듈은 정보 은닉을 수행하는 완벽한 수준의 세분화된 단위를 나타내며(Module.exports) 컴포넌트의 공개 인터페이스만을 노출하고 나머지는 은닉하는 효과적인 메커니즘을 제공한다.<br>
그러나 단순히 어플리케이션이나 라이브러리의 기능을 여러 모듈에 분산시키는 것만으로는 성공적인 디자인이라 할 수 없다. 잘못된 사용 중 한 가지는 독특한 모놀리식(monolithic) 개체를 만들어 내는 것이며, 그 상태에서 모듈을 제거하거나 교체하는 것이 아키텍처의 대부분을 뒤흔들게 된다.<br>
코드를 모듈로 구성하는 방식과 모듈을 서로 연결하는 방식이 전략적인 역할을 하며, 소프트웨어 설계의 모든 문제와 마찬가지로 여러 가지 평가 항목들 사이에서 <strong>적절한 균형</strong>을 찾아야 한다.</p>
<h2 id="응집력과-결합력">7.1.2 응집력과 결합력</h2>
<p>모듈을 만들 때 가장 중요한 두 가지 특성은 <strong>응집력과 결합력이 균형</strong>을 이루는 것이다.<br>
이것들은 소프트웨어 아키텍처에서 모든 유형의 컴포넌트 또는 하위 시스템에 적용될 수 있으므로 노드 모듈을 구축할 때 지침으로 사용할 수 있다.</p>
<p>이 두 속성은 다음과 같이 정의할 수 있다.</p>
<h4 id="응집력cohesion">응집력(Cohesion)</h4>
<p>컴포넌트 기능 간의 <strong>상관관계</strong>에 대한 측도이다.<br>
예를 들어 단 한가지의 작멉한 하는 모듈은, 모듈의 모든 부분이 그 하나의 단일 업무에서만 역할을 할 경우 높은 응집력을 가진다고 할 수 있다. <em>saveProduct(), saveInvoice(), saveUser()</em> 등과 같이 모든 유형의 객체를 데이터베이스에 저장하는 함수를 가진 모듈은 낮은 응집력을 가진다.</p>
<h4 id="결합력coupling">결합력(Coupling)</h4>
<p>구성 요소가 시스템이나 다른 구성 요서에 얼마나 <strong>의존</strong>하는지에 대한 측도이다.<br>
예를 들어, 모듈이 다른 모듈의 데이터를 직접 읽거나 수정하면, 결합력이 높은 모듈이다.<br>
또한 전역이나 공유된 상태를 통해 상호작용하는 모듈들은 밀접한 결합이다.<br>
반면에 매개 변수 전달을 통해서만 두 모듈이 통신한다면 느슨한 결합이라고 할 수 있다.</p>
<p>바람직한 시나리오는 <strong>높은 응집력</strong>과<strong>느슨한 결합</strong>을 가지는 것이다.<br>
이는 일반적으로 재사용 가능하고 확장 가능한 모듈을 뜻한다.</p>
<p><strong>왠만하면 매개변수만 가지고 자기 안에서 끝내는 것을 목표로 하자!</strong><br>
<strong>=&gt; 모듈 단위가 작아질 수 밖에 없음</strong></p>
<h2 id="상태-저장stateful-모듈">7.1.3 상태 저장(Stateful) 모듈</h2>
<p>자바스크립트에서는 모든 것이 하나의 <strong>객체</strong>이다. 인터페이스나 클래스와 같은 추상적이 개념이 없다.<br>
동적 타이핑은 이미 <strong>인터페이스</strong>(또는 <strong>정책</strong>, 패턴)를 <strong>구현</strong>(또는 <strong>세부사항</strong>)에서 분리하는 자연스러운 매커니즘을 제공한다. 그것이 6장에서 본 디자인 패턴 중 일부가 기존 패턴과 비교해서 매우 다르면서 단순해 보이는 이유 중 하나이다.</p>
<p>그러나 자바스크립트에서는 인터페이스와 구현을 분리할 때 작은 문제점을 가지고 있다.<br>
이미 간단하게 노드 모듈 시스템을 사용함으로써 특정 구현체와의 하드코드된 관계를 볼 수 있었다.<br>
정상적인 상태에서는 이 문제가 발생하지 않지만, require()를 사용하여 DB핸들, HTTP 서버 인스턴스, 서비스 인스턴스 같은 상태 저장(stateful) 인스턴스를 외부에 익스포트하는 모듈을 로드하거나 상태 저장이 아닌(stateless) 일반 객체를 익스포트하는 모듈을 로드할 경우, 실제 싱글톤과 매우 유사한 것을 참조하게 됨으로써 주의사항과 장단점을 얻게 된다.</p>
<h3 id="node.js의-싱글톤-패턴">Node.js의 싱글톤 패턴</h3>
<p>Node를 처음 사용하는 사람들은 대부분의 경우 어플리케이션의 다양한 모듈 간에 <strong>단일한 인스턴스</strong>를 공유하기 위한 방법으로 싱클톤 패턴을 선호하게 되고, 어떻게 싱글톤 패턴을 올바르게 구현할 수 있는지를 혼란스러워 한다. 그러나 노드의 대답은 우리의 생각보다 쉽다. 단순히 module.exports를 사용하여 인스턴스를 내보내는 것만으로 이미 싱글톤(Singleton)패턴과 비슷한 것을 얻을 수 있다.</p>
<p>예를 들어 다음과 같은 코드를 생각해 보자.</p>
<pre><code>module.exports = new Database('my-app-db');
</code></pre>
<p>단순히 DB에서 새로운 인스턴스를 내보내는 것만으로도 현재 패키지 내에서 이미 db모듈의 인스턴스가 <strong>하나만 있다고 가정할 수 있다.</strong> 우리가 이미 알다시피 Node.js는 require()의 첫 번째 호출 이후에 모듈을 <strong>캐시</strong>할 것이고, 이후의 호출에서 다시 실행하지 않고 <strong>캐시된 인스턴스를 반환</strong>하기 때문에 가능하다.</p>
<pre><code>const db = require('./db');
</code></pre>
<p>단순히 다음과 같은 코드로 앞에서 정의한 db모듈의 공유 인스턴스를 가져올 수 있다.</p>
<p>이 과정에는 유의사항이 있다. 모듈은 전체 경로를 검색 키로 사용하여 캐시되므로, <strong>현재 패키지 내에서만 싱글톤이 보장된다.</strong><br>
각 패키지가 자신의 node_modules 디렉토리 내에 일련의 자신만의 종속성들을 가질 수 있으므로, 다음과 같은 상황이 발생할 수 있다.</p>
<pre><code>#package.json
{
	"name": "mydb"
	"main": "db.js"
}
</code></pre>
<p>아래과 같은 종속성 트리를 생각해보자.</p>
<pre><code>app/
	ㄴnode_modules
		ㄴpackageA
			ㄴnode_modules
				ㄴmydb
		ㄴpackageB
			ㄴnode_modules
				ㄴmydb
</code></pre>
<p>packageA와 packageB는 모두 mydb 패키지에 종속성을 가지고 있다.<br>
app패키지는 packageA와 packageB에 종속성을 가진다.<br>
실제로 packageA와 packageB는 다음과 같은 명령을 사용해 db인스턴스를 로드할 것이다.</p>
<pre><code>const db = require(mydb);
</code></pre>
<p>이렇게 하면, 같은 mydb지만 패키지에 따라 다른 인스턴스로 해석되기 때문에 packageA와 packageB는 실제로 싱글톤처럼 보이는 두 개의 서로 다른 인스턴스를 로드한다.</p>
<p>이 시점에서 우리는 <code>global.db = new Database('my-app-db');</code>와 같이 선언하지 않는 이상,<br>
앞서 설명된 패턴은 노드 내에 존재하지 않는다고 할 수 있다.</p>
<p>이렇게 하면 인스턴스가 유일한 패키지가 될 뿐 아니라, 비단 한 패키지 뿐만 아니라 전체 어플리케이션에 공유될 것이다. 이것은 <strong>절대 추천되는 상황이 아니다.</strong> 또한 굳이 이렇게 할 필요도 없다.</p>
<h1 id="모듈-연결-패턴">7.2 모듈 연결 패턴</h1>
<p>가중 중요한 유형의 종속성인 상태 저장(Stateful)과 인스턴스의 연결(wiring)에 대해 살펴보자.</p>
<h2 id="하드코딩된-종속성">7.2.1 하드코딩된 종속성</h2>
<p>하드코딩된 의존성을 가지는 두 모듈 간의 일반적인 관계를 살펴보자.<br>
Node.js에서 이것은 클라이언트 모듈이 require()를 사용하여 다른 모둘을 명시적으로 로드할 때 발생한다.<br>
모듈 종속성을 설정하는 이 방법은 간단하고 효과적이지만, 모듈의 재사용을 제한하기 때문에 상태 저장(Stateful) 인스턴스와의 종속성을 하드코딩할 때는 저 주의를 기울여야 한다.</p>
<h3 id="하드코드된-종속성을-사용한-인증-서버-구축">하드코드된 종속성을 사용한 인증 서버 구축</h3>
<pre><code>AuthController -&gt; AuthService -&gt; DB
</code></pre>
<p>위와 같은 구조는 계층화된 아키텍쳐의 전형적인 예이다.<br>
AuthController는 클라이언트로부터 입력을 받아, 요청으로부터 로그인 정보를 추출하고 예비 검증을 수행한다.<br>
그런 다음 AuthService를 사용하여 제공된 자격 증명을 이 데이터베이스에 저장된 정보와 일치하는지 확인한다.<br>
이것은 데이터베이스와 통신하는 수단으로, db모듈을 사용하여 특정 쿼리문을 실행함으로써 수행된다.<br>
이 세 가지 컴포넌트가 함께 연결되는 망식은 재사용성, 테스트 편리성 및 유지관리 가능성 수준을 결정한다.</p>
<p>이러한 구성 요소들을 연결하는 가장 간편한 방법은 AuthService에서 db 모듈을 require한 다음, AuthController에서 AuthService를 require하는 것이다. 이것이 우리가 말하는 <strong>하드코딩된 종속성</strong>이다.</p>
<p>JWT를 통해 사용자를 인증하는 시스템을 구현해 보자.</p>
<pre><code>JWT(Json Web Token은 당사자 간의 클레임을 표현하고 공유하기 위한 형식이다.
단일 페이지 App 및 Cross-Origin Resource Shared(CORS)가 폭발적으로 증가함에 따라,
쿠키 기반 인증보다 유연한 대안으로 인기가 높아지고 있다.
</code></pre>
<blockquote>
<p>lib/db.js<br>
lib/authService.js<br>
lib/authController.js<br>
jwtTest.js<br>
populate_db.js</p>
<p>실행방법<br>
curl -X POST -d “{”“username”": ““alice””, ““password””:"“secret”"}" <a href="http://localhost:3000/login">http://localhost:3000/login</a> -H “Content-Type: application/json”<br>
curl -X GET -H “Accept: application/json” <a href="http://localhost:3000/checkToken?token=">http://localhost:3000/checkToken?token=</a>&lt;토큰&gt;</p>
</blockquote>
<h4 id="db-모듈">db 모듈</h4>
<p>levelUp 데이터베이스 인스턴스를 export.<br>
데이터베이스 핸들 자체를 내보내며, 상태 저장(stateful)인스턴스이다. 따라서 단일 개체를 생성한다.</p>
<h4 id="authservice-모듈">authService 모듈</h4>
<p>사용자 이름/비밀번호 쌍을 검사하고 토큰을 발급하는 login메소드와 토큰의 유효성을 확인하는 checkToken메소드를 가지고 있다.<br>
<code>const db = require('./db');</code><br>
여기서 앞에서 코딩한db모듈을 가져오는 하드코딩된 종속성을 보여준다. 우리는 이 모듈에서 직접적으로 db모듈의 인스턴스를 다루지 않는다.</p>
<p>우리가 만든 모든 인스턴스들은 간단하게 동작하지만, 특정 db인스턴스에 대한 종속성을 하드코딩했기 때문에 코드를 건드리지 않고는 authService를 다른 데이터베이스 인스턴스와 함께 재사용할 수 없다.</p>
<h4 id="authcontroller-모듈">authController 모듈</h4>
<p>상태 유지 모듈 authService에 대한 종속성을 하드코딩한다.<br>
authServiec 모듈은 db모듈에 직접 의존하기 때문에 포함 관계로 인한 이행성 때문에 상태 유지 모듈이 된다. 이런 식으로 하드코딩된 종속성이 전체 App 전반에 쉽게 전파될 수 있다.<br>
<strong>이행성</strong>이란 authService 모듈 자체가 특정 db 인스턴스에 <strong>간접적으로 연결됨</strong>을 의미한다.</p>
<h3 id="하드코딩된-종속성의-장단점">하드코딩된 종속성의 장단점</h3>
<p>모듈 시스템의 모든 기능을 활용하여 Node.js에서 어플리케이션의 다양한 컴포넌트 간에 종속성을 관리하고 모듈을 연결하는 일반적인 방법을 확인하여다.<br>
우리는 모듈에서 상태 저장(Stateful) 인스턴스를 내보내서(export) 호출자에서 생명 주기를 관리하게 한 다음, 그것들을 어플리케이션의 다른 부분에서 직접 require했다. 그 결과 직관적인 구성으로 이해하기 쉽고 디버깅하기 쉬우며, 각 모듈은 외부에서 개입하지 않아도 초기화되고 연결된다.</p>
<p>그러나 상태 유지 인스턴스에 대한 종속성을 하드코딩하면 모듈을 다른 인스턴스에 연결하는 가능성이 제한되어 재사용성이 낮아지며 단위 테스트가 어려워진다.<br>
예를 들어, 다른 DB 인스턴스와 함께 authService모듈을 재사용하는 것은 거의 불가능하다.<br>
마찬가지로 authService를 독립적으로 테스트하는것도 어렵다.</p>
<p>마지막으로 하드코딩된 종속성 사용의 단점은 대부분 <strong>상태 유지(stateful) 인스턴스와 관련되어 있다.</strong> 이것은 우리가 require()를 사용하여 상태가 없는 모듈(팩토리, 생성자, 일련의 상태 비저장 함수)를 로드하는 경우에는 동일한 종류의 문제가 발생하지 않는다는 것을 의미한다.<br>
다시 말해 특정 구현과의 긴밀한 결합은 여전히 존재하지만, Node.js에는 특정 상태와의 결합성(coupling)을 발생시키지 않으므로 일반적으로 컴포넌트의 재사용성에 영향을 주지 않는다.</p>
<h2 id="의존성-주입">7.2 의존성 주입</h2>
<p>DI(Dependency Injection) 패턴은 소프트웨어 설계에서 가장 잘못 이해되고 있는 개념 중 하나다.<br>
많은 사람들은 Spring(Java 및 C#) 또는 Pimple과 같은 프레임워크 및 DI컨테이너와 용어를 일치시켜 생각하지만, 실제로는 훨씬 간단한 개념이다.<br>
DI패턴의 주요 아이디어는 <strong>컴포넌트의 종속성들을 외부 개체에 의해 입력으로 제공하는 것</strong>이다.<br>
이러한 개체는 시스템의 모든 모듈의 연결을 중앙 집중화하는 클라이언트 컴포넌트 또는 전역 컨테이너일 수 있다. 이 접근법의 가장 큰 장점은, 특히 상태 저장 인스턴스 모듈에 대해 디커플링이 향상된다는 것이다.  DI를 사용하여 각 종속성들은 모듈에 하드코딩되지 않고, 외부에서 수신된다. 즉, 모듈이 어떤 종속성이든 사용하도록 설정할 수 있으므로, 다른  컨텍스트에서 재사용할 수 있다.</p>
<p>이 패턴의 설명을 위에 jwt를 리팩토링하고 DI로 모듈을 연결해 보자.</p>
<h3 id="di를-사용한-인증-서버-리팩토링">DI를 사용한 인증 서버 리팩토링</h3>
<p>상태 저장 인스턴스에 대한 종속성을 하드코딩하는 대신에, 일련의 종속성을 인수로 취하는 팩토리를 생성함으로써 DI를 사용할 수 있다.</p>
<blockquote>
<p>DIlib/db.js<br>
DIlib/authService.js<br>
DIlib/authController.js<br>
DIapp.js</p>
</blockquote>
<h4 id="db.js">db.js</h4>
<p>db 모듈을 팩토리로 변경한다. 결과적으로 원하는 만큼의 데이터베이스를 만들 수 있게 되었으며, 이는 전체 모듈이 이제 재사용 가능하며 상태 비저장(stateless)임을 뜻한다.</p>
<h4 id="authservice.js">authService.js</h4>
<p>authService 모듈 또한, db와 토큰 비밀번호를 입력받아 서비스를 생성하는 팩토리로 생성함으로써, 상태 비저장(stateless)가 되었다. 더 이상 특정한 인스턴스를 익스포트하는 것이 아니라, 단순히 팩토리를 익스포트한다. 가장 중요한 사항은 이전의 하트코딩된 db종속성을 제거하고 팩토리 함수의 인수로 <strong>주입</strong>할 수 있다는 것이다.</p>
<h4 id="authcontroller.js">authController.js</h4>
<p>authController 모듈에도 이제 하드코딩된 의존성이 없어졌다. 심지어는 상태 비저장(stateless)도 없다. 유일한 의존성인 authService모듈은 호출하는 순간 팩토리에 입력으로 주어진다.</p>
<h4 id="diapp.js">DIapp.js</h4>
<p>수정한 대로 팩토리를 통해 전달받고, 또 전달받은 모듈 주입시킨다.</p>
<p>우선 서비스의 팩토리들을 로드한다. 이 시점에서 그들은 여전히 상태 비저장(stateless)객체이다.<br>
다음으로 필요한 종속성들을 주입하여 각 서비스를 인스턴스화한다.<br>
마지막으로 authController모듈의 라우트들을 익스프레스 서버에 등록록한다.</p>
<h3 id="다양한-유형의-di">다양한 유형의 DI</h3>
<p>방금 예시에서 DI의 한 유형인 <strong>팩토리 인젝션</strong>을 보았다.<br>
이외에 DI패턴으로는 다음과 같은 DI가 있다.</p>
<h4 id="생성자-인젝션">생성자 인젝션</h4>
<p>이 유형의 DI에서는 의존성이 생성 순간에 생성자에게 전달된다.</p>
<pre><code>const service = new Service(dependencyA, dependencyB);
</code></pre>
<h4 id="속성-인젝션">속성 인젝션</h4>
<p>종속성이 생성된 객체에 아래와 같이 첨부한다.</p>
<pre><code>const service = new Service();//팩토리 사용 가능
service.dependencyA = anInstanceOfDependencyA;
</code></pre>
<p>속성 인젝션은 객체와 종속성이 서로 연결되지 않기 때문에, 객체가 일관성 없는 상태로 생성된다는 것을 의미하므로 덜 강력하다. 하지만 종속성 간의 순환이 있을 때는 유용하다.<br>
예를 들어 팩토리 또는 생성자 주입을 사용하는 A와 B 두 가지 컴포넌트가 있는데, 두 컴포넌트가 서로에게 종속성이 있는 경우 둘 중 하나는 인스턴스화할 수 없다.<br>
왜냐면 둘 다 생성되기 위해서는 상대 컴포넌트가 요구되기 때문이다.</p>
<pre><code>function Afactory(b){
	return {
		foo: function(){
			b.say();
		},
		what: function(){
			return 'Hello!';
		}
	}
}
function Bfactroy(a){
	return {
		a: a,
		say: () =&gt; {
			console.log('I say: a.what);
		}
	}
}
</code></pre>
<p>앞의 소스같은 경우 두 팩토리 간의 종속성 교차 생태를 속성 인젝션을 통해 해결할 수 있다.<br>
아래와 같이 불완전한 B 인스턴스를 먼저 생성한 다음, A를 생성하는데 사용한다.<br>
마지막으로 상대 속성을 통해 A에 B를 삽입한다.</p>
<pre><code>const b = Bfactory(null);
const a = Afactory(b);
a.b = b;
</code></pre>
<h3 id="di의-찬반론">DI의 찬반론</h3>
<p>DI를 사용한 인증 서버 예제에서 모듈을 특정 종속성 인스턴스로부터 분리할 수 있었다.<br>
그 결과 우리는 최소한의 노력으로 각 모듈을 재사용할 수 있게 되었다.<br>
DI패턴을 사용한 모듈을 테스트하는 작업 또한 간단하게 할 수 있다.</p>
<p>또 다른 중요한 점은, 의존 관계를 연결하는 책임을 아키텍쳐의 맨 아래에서 맨 위로 옮겼다는 점이다. 상위 수준의 컴포넌트(App)이 하위 수준의 컴포넌트(db)보다 재사용성이 낮고, 컴포넌트가 더 많이 구체화된다는 것에 기반한다.</p>
<p>이 가정을 바탕으로, 우리는 상위 수준 컴포넌트가 그들의 낮은 수준의 종속성에 관여하지 않는다는 어플리케이션 아키텍쳐를 보는 전통적인 방식을 뒤집을 수 있다는 것을 알 수 있다.<br>
하위 수준의 컴포넌트는 인터페이스에서만 의존하므로, 종속성 구현을 정의하는 책임은 상위 수준 컴포넌트에 부여된다. 실제, 우리의 인증 서버에서는 모든 의존성이 가장 위의 컴포넌트, 즉 재사용성이 낮고 결합 측면에서 가장 소모적인 app모듈에서 인스턴스화되고 결합된다.</p>
<p>그러나 디커플링 및 재사용성 측면에서 이러만 모든 장점은 <strong>비용을 지불해야 한다.</strong><br>
일반적으로 코딩을 할 때 의존성을 해결할 수 없으면, 시스템의 다양한 컴포넌트들 간의 관계를 이해하기가 더욱 어려워진다. 또한 앱 모둘의 모든 종속성을 인스턴스화하는 방식을 살펴보면 특정 순서를 따라야 한다는 것을 알 수 있다. 사실상 우리는 전체 어플리케이션의 종속성 그래프를 수동으로 구축하였다. 이것은 연결해야 할 모듈 수가 많아질 때 관리하기 어려워질 수 있다.</p>
<p>이 문제에 대한 실행 가능한 솔루션은, 여러 컴포넌트들 간의 종속성 소유권을 <strong>분할</strong>하는 것이다. 이렇게 하면 각 컴포넌트가 특정 종속성 하위 그래프만 담당하므로, 기하급수적으로 증가하는 종속성을 관리하는 복잡함을 줄일 수 있다.<br>
즉, 어플리케이션의 모든 부분에 DI를 적용하는 대신, 필요할 때 부분적으로 DI를 사용하는 방법을 선택할 수도 있다.</p>
<p>또한, 복잡한 아키텍쳐에서 모둘들의 연결을 단순화하는 또 다른 해결책은 어플리케이션의 모든 종속성을 인스턴스화하고 연결해주는 것을 독점적으로 책임지는 컴포넌트인 <strong>DI 컨테이너</strong>를 사용하는 것이다.</p>
<p>DI를 사용하면 모듈의 복잡성과 장황함이 증가하지만, 이전에 보았듯 이렇게 하는데는 여러 가지 이유가 있다. 단순성과 재사용성 사이의 <strong>균형</strong>에 따라 알맞은 접근법을 선택하는 것이 중요하다.</p>
<h2 id="서비스-로케이터">7.2.3 서비스 로케이터</h2>
<p>DI와 매우 유사한 의도를 가진 패턴으로 <strong>서비스 로케이터</strong>패턴이 있다.<br>
핵심 원칙은 시스템의 컴포넌트를 관리하고 모듈이 종속성을 로드해야 할 때마다 중재자 역할을 수행할 수 있도록 <strong>중앙의 레지스트리를 갖는 것</strong>이다.<br>
방식은 하드코딩을 대신해서, 서비스 로케이터에게 종속성을 요청하는 것이다.</p>
<p>서비스 로케이터를 사용하여 모듈에 연결하는 방식에 따라 <strong>커플링</strong>의 수준과 재사용성이 결정된다. Node,js에서는 시스템의 다양한 컴포넌트들에 연결되는 방식에 따라 세 가지 유형의 서비스 로케이터로 구현할 수 있다.</p>
<ul>
<li>종속성이 하드코딩된 서비스 로케이터</li>
<li>주입식(Injected) 서비스 로케이터</li>
<li>글로벌 서비스 로케이터</li>
</ul>
<p>첫 번째는 디커플링 측면에서 가장 적은 장점을 가진 것으로, require()를 사용하여 서비스 로케이터의 인스턴스를 <strong>직접 참조</strong>하는 것으로 구성된다. Node.js에서 이것은 더 나은 분리(디커플링)를 제공하기 위해 의도된 특정 컴포넌트와 밀접한 결합을 유지하기 때문에 안티패턴(anti-pattern)으로 간주될 수 있다. 이 경우의 서비스 로케이터는 재사용성 측면에서 어떤 가치도 제공하지 않고 오히려 부정적인 영향과 복잡성만이 추가된다.</p>
<p>반면, 주입식(Injected) 서비스 로케이터는 <strong>DI를 통해서 컴포넌트에서 참조</strong>된다. 이는 전체 종속성 세트를 하나씩 제공하는 대산 전체 종속성 세트를 한 번에 주입하는 보다 편리한 방법으로 간주될 수 있다.</p>
<p>서비스 로케이터를 참조하는 세 번째 방법은 <strong>전역 범위에서 직접 가져오는 것</strong>이다. 하드코딩된 서비스 로케이터의 단점과 동일한 단점이 있지만, 전역적이고 실제 싱글톤이므로 패키지간에 인스턴스를 공유하기 위한 패턴으로 쉽게 사용할 수 있다. 다만 지금은 글로벌 서비스 로케이터를 사용할 이유가 거의 없다.</p>
<h3 id="서비스-로케이터를-사용한-인증-서버-로케이터">서비스 로케이터를 사용한 인증 서버 로케이터</h3>
<p>주입식(Injected) 서비스 로케이터를 사용해보자.</p>
<pre><code>#serviceLocator.js
module.exports = () =&gt; {  
    const dependencies = {};  
    const factories = {};  
    const serviceLocator = {};  
  
   serviceLocator.factory = (name, factory) =&gt; {  
        factories[name] = factory;  
   };  
  
  serviceLocator.register = (name, instance) =&gt; {  
        dependencies[name] = instance;  
  };  
  
  serviceLocator.get = (name) =&gt; {  
	  if (!dependencies[name]) {  
        const factory = factories[name];  
		dependencies[name] = factory &amp;&amp; factory(serviceLocator);  
		if (!dependencies[name]) {  
           throw new Error('Cannot find module: ' + name);  
		}  
      }  
      return dependencies[name];  
 };
  
 return serviceLocator;  
};
</code></pre>
<p>factory()는 컴포넌트의 이름을 해당 팩토리와 연결시키기 위해 사용된다.<br>
register()는 컴포넌트의 이름을 인스턴스와 직접 연관시키는데 사용된다.<br>
get()은 이름으로 컴포넌트를 검색한다. 인스턴스가 이미 사용 가능한 경우 인스턴스를 반환하지만, 그렇지 않으면 등록된 팩토리를 호출하여 새 인스턴스를 얻으려고 시도한다. 모듈 팩토리들에 현재 서비스 로케이터의 인스턴스를 <strong>주입</strong>하여 호출한다.</p>
<p>서비스 로케이터를 사용하는 모듈들은, 서비스 로케이터를 입력(주입)으로 사용하는 팩토리이다.<br>
모듈의 종속성들은(외부의 환경 변수 및 핸들러) 서비스 로케이터의 register혹은 factory를 통해 등록하고 종속성을 가지는 모듈 내에서 get() 메소드를 통해 조회된다.</p>
<pre><code>#app.js
const svcLoc = require('./lib/serviceLocator')();

svcLoc.register('dbName', 'example-db');
svcLoc.register('tokenSecret', 'SHHH!');
svcLoc.factory('db', require('./lib/db'));
svcLoc.factory('authService', require('./lib/authService'));
svcLoc.factory('authController', require('./lib/authController'));

const authController = svcLoc.get('authController');

app.post('/login', authController.login);
app.get('/checkToken', authController.checkToken);
</code></pre>
<p>우선 팩토리를 호출하여 새로운 서비스 로케이터를 인스턴스화한다.<br>
서비스 로케이터에 대해 환경 변수 및 모듈 팩토리를 등록한다. 단지 방금 팩토리를 등록한 것이므로, 모든 종속성은 인스턴스화되지 않았다. 여기서 <strong>지연 생성</strong>이 발생한다. 각 인스턴스는 팩토리를 등록해 둔 후 필요한 경우에만 만들 수도 있다.<br>
실제로 모든 종속성은 수동으로 미리 수행할 필요없이 자동으로 연결된다.<br>
장점은 모듈을 인스턴스화하고 연결하기 위한 올바른 순서가 무엇인지 알 필요가 없다는 것이다.<br>
모든 것이 자동 및 필요 시에 발생한다. 이것은 단순한 DI패턴에 비해 훨씬 편리하다.</p>
<pre><code>Express 서버 내에서도 app.set(name, instance)를 사용하여 서비스를 등록하고,
app.get(name)를 사용하여 등록된 서비스를 조회할 수 있다.
서비스 로케이터 역할을 하는 서버 인스턴스가 이미 각 미들웨어에 주입되어 있고,
request.app을 이용하여 app에 접근할 수 있다는 것이 이 패턴의 편리한 부분이다.
</code></pre>
<h3 id="서비스-로케이터의-장단점">서비스 로케이터의 장단점</h3>
<p>서비스 로케이터와 의존성 주입(DI)는 공통점이 많다. 둘 다 의존성 처리의 책임을 컴포넌트의 <strong>외부 개체로 이관</strong>시킨다.  서비스 로케이터를 연걸하는 방법이 전체 아키텍쳐의 유연성을 결정하게 된다.<br>
require()를 사용하여 컴포넌트를 의존성에 직접 결합하는 것을 대신하여 서비스 로케이터의 특정 인스턴스와 결합하였다.<br>
또한 DI와 마찬가지로 서비스 로케이터를 사용하면 컴포넌트가 런타임에 resolve되기 때문에 컴포넌트간의 관계를 식별하기가 더 어려워진다. 서비스 롱케이터는 종속성이 자동으로 연결되므로, 특정 컴포넌트에 어떤 종속성이 필요한지 정확히 파악하기가 더 어렵다.<br>
DI를 사용하면 팩토리 내에 선언하거나 생성자의 인자를 사용하여 더 명확하게 표현한다.<br>
서비스 로케이터의 경우 이 방법이 명확하지 않으므로, 코드 검사툴 또는 종속성을 명시한 도큐먼트가 필요하다.</p>
<p>서비스 로케이터와 DI 컨테이너가 동일한 역할을 공유하기 때문에, 이를 잘못 해석하는 경우가 많다.<br>
이 두가지 사이에는 커다란 차이점이 존재하는데, 서비스 로케이터를 사용하면 각 컴포넌트가 <strong>서비스 로케이터로부터 명시적으</strong>로 자신의 종속성을 로드한다. 대신 DI컨테이너를 사용하는 경우 컴포넌트는 <strong>컨테이너에 대해 알지 못한다.</strong><br>
이 두가지 접근 방식의 차이는 재사용성과 종속성에서 두드러진다.<br>
서비스 로케이터에 의존하는 컴포넌트는 시스템에서 서비스 로케이터를 사용할 수 있어야 하기 때문에 재사용성이 적다.<br>
또한 서비스 로케이터는 컴포넌트가 필요로 하는 종속성의 식별이 불분명하다.</p>
<p>재사용성 측면에서 서비스 로케이터 패턴이 하드코딩된 종속성과 DI사이에 위치한다고 할 수 있다.<br>
편리하고 간단하다는 점에서는 전체 종속성 그래프를 수동으로 작성하지 않아도 된다는 점에서 DI보다 낫다.</p>
<h2 id="의존성-주입di컨테이너">7.2.4 의존성 주입(DI)컨테이너</h2>
<p>서비스 로케이터를 DI 컨테이너로 변환하는 단계는 디커플링 측면에서 큰 차이가 있다.<br>
이 패턴으로 인해 각 모듈은 서비스 로케이터에 의존할 필요가 없어진다.<br>
필요 종속성을 표현할 수 있으며, DI컨테이너가 나머지를 원할하게 수행해 준다.<br>
이 메커니즘의 장점은 모든 모듈이 컨테이너 없이도 재사용될 수 있다는 것이다.</p>
<h3 id="di컨테이너에-대한-종속성-선언">DI컨테이너에 대한 종속성 선언</h3>
<p>DI컨테이너는 본질적으로 모듈을 인스턴스화하기 전에 모듈이 필요로 하는 종속성을 식별하는 기능을 추가한 서비스 로케이터이다. 이것을 위해 모듈은 어떤 식으로든 의존성을 선언해야 한다.</p>
<p>가장 많이 사용되는 방법은 팩토리 또는 생성자에서 인수의 이름을 기반으로 일련의 종속성을 주입하는 것이다.</p>
<pre><code>module.exports = (db.tokenSecret) =&gt; {
	//...
}
</code></pre>
<p>앞서 정의한 모듈은 매우 간단하고 직관적인 매커니즘을 그린 db 그리고 tokenSecret이라는 종속성 이름을 사용하여 DI 컨테이너에 의해 인스턴스화 한다. 그러나 함수 인자의 이름을 읽는 데는 약간의 트릭이 필요하다.</p>
<p>자바스크립트에서는 함수를 직렬화하여 런타임에 소스코드를 얻을 수 있다.</p>
<pre><code>함수의 인자명을 사용하여 종속성 집합을 주입하는 것은 Google에서 개발하였으며,
DI컨테이너 위에 구축된 클라이언트 측 JavaScript 프레임워크인 AngularJS에 의해 널리 보급되었다.
</code></pre>
<p>이 방법의 가장 큰 문제는 소스코드의 크기를 최소화하기 위해, 클라이언트 즉 JS에서 광범위하게 사용되는 특정 코드로의 변환하는 방식인 최소화(minification)와 잘 맞지 않는다는 것이다.<br>
많은 minificators는 기본적으로 길이를 줄이기 위해 로컬 변수의 이름을 일반적으로 단일 문자로 바꾸는 <strong>네임 맹글링</strong>으로 알려진 기술을 적용한다.<br>
함수 인자는 일반적으로 지역 변수이므로 이 프로세스의 영향을 받음으로써, 종속성을 선언하기 위해 사용하는 이 메커니즘을 무너뜨린다.<br>
서브 측 코드에서 최소화가 실제로 필요한 것은 아니지만, Node.js모듈이 브라우저와 공유되는 경우가 많으므로, 고려해보아야 한다.<br>
DI는 몇 가지 기술들을 통해 어떤 종속성을 주입할 지를 알 수 있다.</p>
<ul>
<li>팩토리 함수에 추가된 특수한 속성을 사용할 수 있다. 예를 들어, 주입을 위한 모든 종속성을 명시적으로 나열한 배열을 사용할 수 있다.</li>
</ul>
<pre><code>module.exports = (a, b) =&gt; {};
module.exports._inject = ['db','another/dependency'];
</code></pre>
<ul>
<li>모듈을 종속성 이름과 팩토리 함수를 담은 배열로 지정할 수 있다.</li>
</ul>
<pre><code>module.exports = ['db', 'another/dependency', (a, b) =&gt; {}];
</code></pre>
<h3 id="di컨테이너를-사용한-인증-서버-리팩토링">DI컨테이너를 사용한 인증 서버 리팩토링</h3>
<p>DI컨테이너가 서비스 로케이터보다 훨씬 더 독립적인 방식이라는 것을 보여주기 위해 앞서 만든 인증 서버를 다시 리팩토링해보자.<br>
컨테이너의 초기화를 담당하는 모듈로 사용할 app.js 모듈을 제외만 어플리케이션의 모든 컴포넌트를 그대로 둔다.</p>
<pre><code>#diContainer.js
const fnArgs = require('parse-fn-args');

module.exports = () =&gt; {
  const dependencies = {};
  const factories = {};
  const diContainer = {};
  
  diContainer.factory = (name, factory) =&gt; {
    factories[name] = factory;
  };
  
  diContainer.register = (name, dep) =&gt; {
    dependencies[name] = dep;
  };
  
  diContainer.get = (name) =&gt; {
    if (!dependencies[name]) {
      const factory = factories[name];
      dependencies[name] = factory &amp;&amp; 
          diContainer.inject(factory);
      if (!dependencies[name]) {
        throw new Error('Cannot find module: ' + name);
      }
    }
    return dependencies[name];
  };
  
  diContainer.inject = (factory) =&gt; {
    const args = fnArgs(factory)
      .map(function(dependency) {
        return diContainer.get(dependency);
      });
    return factory.apply(null, args);
  };
  
  return diContainer;
};
</code></pre>
<p>함수 인자들의 추출을 위해 parse-fn-args라는 모듈을 사용하였다. 이 모듈은 함수 인자들의 이름을 추출하는데 사용된다.<br>
모듈 팩토리를 직접 호출하는 대신 diContainer모듈의 또 다른 메소드인 inject()를 사용한다. inject()메소드는 모듈의 종속성을 해결(resolve)하고 이를 사용하여 팩토리를 호출한다.</p>
<pre><code>diContainer.inject = (factory) =&gt; {
    const args = fnArgs(factory)
      .map(function(dependency) {
        return diContainer.get(dependency);
      });
    return factory.apply(null, args);
};
</code></pre>
<p>위 방법이 서비스 로케이터와 DI 컨테이너의 차이다.</p>
<ol>
<li>parse-fn-args 라이브러리를 사용하여 입력으로 받은 팩토리 함수에서 인자들의 목록을 추출한다.</li>
<li>각 인자 이름을 get()메소드로 조회하여 해당 종속성 인스턴스에 맵핑한다.</li>
<li>마지막으로 방금 생성한 종속성 목록을 제공하여 팩토리를 호출한다.</li>
</ol>
<p>서비스 로케이터와 크게 다르지는 않지만, 의존성을 주입하여 모듈을 인스턴스화하는 간단한 과정은 서비스 로케이터 전체를 주입하는 것과 비교하여 큰 차이를 만든다.</p>
<pre><code>#app.js
const diContainer = require('./lib/diContainer')();

diContainer.register('dbName', 'example-db');
diContainer.register('tokenSecret', 'SHHH!');
diContainer.factory('db', require('./lib/db'));
diContainer.factory('authService', require('./lib/authService'));
diContainer.factory('authController', require('./lib/authController'));

const authController = diContainer.get('authController');

app.post('/login', authController.login);
app.get('/checkToken', authController.checkToken);
</code></pre>
<p>app모듈의 코드는 서비스 로케이터를 초기화할 때 사용했던 코드와 동일하다.<br>
또한 DI컨테이너를 로딩하여 전체 종속성 그래프를 시작시키기 위해 여전히 diContainer.get(‘authController’)를 사용하여 서비스로케이터로 사용해야 한다.</p>
<h3 id="di-컨테이너의-장단점">DI 컨테이너의 장단점</h3>
<p>DI컨테이너는 모듈이 DI패턴을 사용하므로 대부분의 장단점을 상속받았다고 할 수 있다.<br>
디커플링과 테스트 가능성은 높지만, 의존성이 런타임에 해결되기 때문에 복잡성이 더 증가했다.<br>
또한 DI컨테이너는 서비스 로케이터 패턴과 많은 특성을 공유하지만 실제로 의존성을 제외한 추가적인 서비스에 의존하도록 모듈을 강제하지는 않는다.<br>
이는 간단한 수작업으로 DI 컨테아너 없이도 각 모듈을 사용할 수 있기 때문에 큰 장점이다.</p>
<p>이 예제에서는 기본적으로 일반 DI패턴을 사용한 인증 서버의 구현체를 가져와 해당 컴포넌트를 수정하지 않고도 모든 종속성 주입을 자동화할 수 있었다.</p>
<h1 id="연결wiring을-위한-플러그인">7.3 연결(Wiring)을 위한 플러그인</h1>
<p>소프트웨어 엔지니어의 꿈의 아키텍쳐는 플러그인을 사용하여 필요에 따라 확장 가능한 작고 최소한의 코어를  갖춘 아키텍쳐이다. 대부분의 경우 시간, 자원 및 복잡성 면에서 비용이 발생하므로 항상 쉽게 얻을 수는 없다.</p>
<p>그럼에도 불구하고 시스템의 일부분이라도 외부 확장성을 지원하는 것은 언제나 바람직하다.</p>
<ul>
<li>플러그인에 어플리케이션의 서비스를 공개하기</li>
<li>부모 어플리에키션의 흐름에 플러그인 통합하기</li>
</ul>
<h2 id="패키지로서의-플러그인">7.3.1 패키지로서의 플러그인</h2>
<p>종종 Node.js에서 어플리케이션의 플러그인은 프로젝트의 node_modules 디렉터리에 <strong>패키지로 설치</strong>된다.<br>
이렇게 함으로써 npm의 기능을 활용하여 플러그인을 배포하고 종속성을 관리할 수 있다. 또한 패키지의 자체적신 종속성 그래프가 있을 수 있으므로, 플러그인이 상위 프로젝트의 종속성을 사용하는 것과는 달리 종속성 간에 충돌 및 비호환성이 발생할 가능성이 줄어든다.</p>
<p>또한 패키지를 사용함으로써 외부 플러그인을 가져올 뿐만 아니라, 다른 패턴에도 사용될 수 있다.<br>
실제로 잘 사용되는 패턴은 어플리케이션이 자신의 모든 컴포넌트들을 외부 플러그인 인 것처럼 패키지 안에 감싸서 어플리케이션 전체를 빌드하는 것이다.</p>
<p>따라서 어플리케이션의 메인 패키지 내에 모듈들을 구성하는 대신, 기능의 큰 덩어리 별로 별도의 패키지를 만들어 node_modules 디렉토리에 설치할 수 있다.</p>
<p>사람들이 상대 경로 표기법을 사용하여 패키지의 모듈을 참고하는 것이 비현실적이거나 너무 장황한 경우가 있다.</p>
<pre><code>application
ㄴcomponentA
	ㄴsubdir
		ㄴmoduleA
ㄴcomponentB
	ㄴmodule
</code></pre>
<p>moduleA에서 moduleB를 참조하려면 다음과 같이 작성해야 한다.</p>
<pre><code>require('../../componentB/moduleB');
</code></pre>
<p>대신 require()의 resolve알고리즘 특징을 활용하여, 전체 컴포넌트 디렉토리를 패키지에 넣을 수 있다. 컴포넌트B를 node_modules 디렉토리에 설치하면, 다음과 같이 작성할 수 있다.</p>
<pre><code>require('componentB / module');
</code></pre>
<p>재사용성을 이유로 이와 같이 프로젝트를 패키지로 분할하기도 한다. 패키지는 자체적인 private의존성을 가질 수 있으며, 이것은 개발자로 하여금 전체 어플리케이션의 디커플링과 정보 은닉에 유익한 영향을 줄 수 있도록 메인 어플리케이션에 무엇을 노출시킬 것인지 그리고 무엇을 사적으로 유지할 것인지 고려하게 한다.</p>
<pre><code>npm과의 조합만으로 코드를 배포하는 것이 아니라,
패키지를 어플리케이션을 구성하는 수단으로 사용해보자.
</code></pre>
<p>이 사례는 stateless한 재사용 가능한 라이브러리로서뿐만 아니라, 패키지를 활용하여 특정 어플리케이션의 통합된 일부로서 서비스를 제공하여 그 기능을 확장하거나 그 동작을 변경할 수 있다. 가장 큰 차이점은 이러한 유형의 패키지는 그냥 사용되는 것이 아니라 어플리케이션 내부에 <strong>통합</strong>된다는 것이다.</p>
<pre><code>특정 어플리케이션과 통합할 패키지를 설명하는데 plugin이라는 용어를 사용한다.
</code></pre>
<p>앞으로 살펴 보겠지만, 이 유형의 아키텍쳐를 지원하기로 결정하는 순간 직면하는 공통적인 문제는 메인 어플리케이션의 일부를 플러그인에 노출시키는 것이다.<br>
사실 완벽한 확장성을 위해 stateless plugin만 고려할 수는 없다. 왜냐하면, 종종 플러그인이 작업을 수행하기 위해 부모 어플리케이션의 일부 서비스를 사용해야 하기 때문이다.<br>
이 측면은 부모 어플리케이션에서 모듈을 연결하는 데 사용되는 기술에 크게 의존한다.</p>
<h2 id="확장-포인트">7.3.2 확장 포인트</h2>
<p>어플리케이션을 확장하는 방법은 무궁무진하다.<br>
프록시나 데코레이터를 사용하여 서비스의 기능을 변경하거나 향상시킬 수 있다.<br>
전략을 사용하여 알고리즘의 일부를 교체할 수도 있고, 미들웨어를 통해 기존의 처리 파이프라인에 다른 처리 단위를 삽입할 수도 있다. 또한 스트림은 구성 가능한 그 특징으로 인해 큰 확장성을 제공할 수 있다.<br>
반면 <strong>이벤트 이미터</strong>를 사용하면 이벤트로 게시(publish)/구독(subscribe) 패턴을 사용하여 컴포넌트를 분리할 수 있다.</p>
<p>또 다른 중요한 기술은 어플리케이션에서 새로운 기능을 추가하거나 기존 기능을 수정할 수 있는 지점을 <strong>명시적으로 정의</strong>하는 것이다.<br>
어플리케이션의 이러한 지점을 일반적으로 후크(hook)라고 한다.<br>
요약하면, 플러그인을 지워하기 위한 가장 중요한 요소는 일련의 <strong>확장 포인트</strong>들이다.<br>
컴포넌트를 연결하는 방식도 플러그인에 어플리케이션의 서비스를 노출시키는 방법에 영향을 줄 수 있으므로 결정적인 역할을 한다.</p>
<h2 id="플러그인-제어와-어플리케이션-제어-확장">7.3.3 플러그인 제어와 어플리케이션 제어 확장</h2>
<p>어플리케이션의 컴포넌트를 확장하는데는 주로 두 가지 방법이 있다.</p>
<ul>
<li>명시적인 확장</li>
<li>IoC(Inversion on Control: 제어 반전)을 통한 확장</li>
</ul>
<p>첫 번째 경우에는 인프라를 명시적으로 확장하는 보다 구체적인 컴포넌트(새로운 기능을 제공)을 가진다.<br>
반면에 두 번째 경우는 특정 컴포넌트를 로드, 설치 또는 실행하여 확장을 제어하는 인프라이다.</p>
<p>IoC는 어플리케이션 확장성의 문제뿐만 아니라 매우 광범위하게 사용되는 원칙이다.<br>
실제로 인프라 스트럭쳐를 제어하는 맞춤형 코드를 사용하는 대신 특정 형식의 IoC를 구현하면 인프라 스트럭쳐가 사용자 지정 코드를 제어하는 것이라고 할 수 있다.<br>
IoC를 사용하면, 어플리케이션의 다양한 컴포넌트가 흐름을 제어하는 능력을 <strong>상실</strong>하는 대신 <strong>디커플링의 수준을 향상</strong>시킨다.<br>
이것은 <strong>할리우드의 원칙( Hollywood principle)</strong> 또는 "연락은 우리가 하겠습니다(don’t call us, we’ll call you)"로 알려져 있다.<br>
예를 들어, DI컨테이너는 종속성 관리라는 특정 사례에 적용되는 IoC원칙의 일례이다.<br>
Observer 패턴은 상태 관리에 적용되는 IoC의 또 다른 예이다.<br>
템플릿(Template), 전략(Strategy), 상태(State) 그리고 미들웨어(Middleware)도 동일한 원칙의 보다 특성화된 표현이다. 브라우저는 UI이벤트를 Javascript코드로 보낼 때 IoC 원칙을 구현하고 있다.<br>
특정 사례의 플러그인에 이 개념을 적용하면 두 가지 형태의 확장을 확인할 수 있다.</p>
<ul>
<li>플러그인이 제어하는 확장(Plugin-controlled extension)</li>
<li>어플리케이션이 제어하는 확장(IoC)</li>
</ul>
<p>첫 번째 경우에는 필요에 따라 어플리케이션 컴포넌트를 플러그인에 제공하여 확장하는 플러그인인 반면, 두 번째 경우에는 어플리케이션의 확장 지점 중 한 곳에 플러그인을 통합하여 제어가 어플리케이션에 맡겨진다.</p>
<p>빠른 예제를 만들기 위해, 새로운 라우터를 가지고 Express 어플리케이션을 확장하는 플러그인을 생각해 보자. 플러그인이 제어하는 확장을 사용하면 다음과 같은 형식이 된다.</p>
<pre><code>//어플리케이션에서의 코드
const app = express();
require('thePlugin')(app);

//플러그인에서의 코드
module.exports = function plugin(app){
	app.get('/newRoute', function(req, res){ ... })
};
</code></pre>
<p>대신 어플리케이션이 제어하는 확장(IoC)를 사용하려는 경우 다음과 같이 적용한다.</p>
<pre><code>//어플리케이션의 코드
const app = express();
const plugin = require('thePlugin')();
app[plugin.method](plugin.route, plugin.handler);

//플러그인에서의 코드
module.exports = function plugin(){
	return{
		method: 'get',
		route: '/newRoute',
		handler: function(req, res){...}
	}
};
</code></pre>
<p>플러그인이 어떻게 확장이라는 전반적인 프로세스에서 수동적으로 적용되는가?<br>
위의 두 번째 예시에서, 플러그인은 단순히 메소드와 핸들러를 포함한 객체를 반환할 뿐이고, 이에 대한 실행은 어플리케이션에서 담당한다. 제어는 플러그인을 받아들이게 만들어진 프레임워크를 가진 어플리케이션에 있다.<br>
앞의 예의 기초하여 두 가지 접근 방식의 차이점을 확인해보자.</p>
<ol>
<li>어플리케이션 내부에 대한 액세스 권한이 있는 경우가 많으므로 플러그인이 제어하는 확장이 더 강력하고 유연하며, 플러그인이 어플리케이션 자체의 일부가 아니어서 자유롭게 이동할 수 있다. 그러나 이것은 때때로 장점보다는 책임 문제일 수 있다. 어플리케이션의 모든 변경 사항이 플러그인에 보다 쉽게 영향을 미치기 때문에, 메인 어플리케이션의 변경 사항에 따라 지속적인 플러그인의 업데이트가 필요하다.</li>
<li>어플리케이션에서 확장을 제어하기 위해 플러그인을 위한 인프라가 요구된다. 플러그인이 제어하는 확장의 경우 유일한 요건은 어플리케이션의 컴포넌트를 어떤 방식으로든 확장할 수 있어야 한다는 것이다.</li>
<li>플러그인이 제어하는 확장을 사용하기 위해서는, 어플리케이션의 내부 서비스를 플러그인과 공유해야 한다. <code>require('plugin')(app) //어플리케이션 인스턴스 자체를 전달</code> 어플리케이션이 제어하는 확장을 사용하면, 확장만이 아니라 사용을 위해서라도 어플리케이션의 일부 서비스에 엑세스할 수 있어야 한다. 예를 들어 플러그인으로 db인스턴스에 쿼리를 하거나 몇 가지 시나리오의 이름을 기록하기 위해 로거를 사용할 수 있다.</li>
</ol>
<p>그렇다면 마지막 항목에서, 어플리케이션의 서비스를 플로그인에 노출하는 것이 얼마나 중요한가? 이를 판단하기 위한 가장 좋은 방법은 인프라스트럭쳐 측면에서 플러그앤플레이 방식의 확장에 대해 실질적인 예를 보여주는 것이다. 어플리케이션의 상태를 플러그인과 공유하는 문제에 대해 생각해보자.</p>
<h2 id="로그아웃-플러그인-구현하기">7.3.4 로그아웃 플러그인 구현하기</h2>
<p>명시적으로 토큰을 무효화할 수 없던 앞의 예제에 로그아웃 기능을 추가해보자.</p>
<p>메인 어플리케이션 코드를 수정하지 않고 외부 플러그인에 작업을 위임하여 이를 수행하려 한다.<br>
이 기능을 지원하려면 데이터베이스를 만든 후에 각 토큰을 데이터베이스에 저장하고, 유효성을 검사할때마다 해당 토큰을 확인해야 한다. 토큰을 무효화하려면 데이터베이스에서 토큰을 제거하기만 하면 된다.</p>
<p>이를 위해 authService.login 및 authService.checkToken에 대한 호출을 프록시 처리하기 위해 플러그인이 제어하는 확장을 사용할 것이며, logout()이라는 새로운 메소드로 authService를 데코레이트 할 것이다. 이 작업을 마친 후에는 메인 Express 서버에 새 라우트를 등록하여 새로운 엔드포인트(/logout)을 오픈한 후, HTTP 요청을 사용하여 토큰을 무효화하게 할 것이다.<br>
4가지 변형을 사용하여 예제를 구현한다.</p>
<ul>
<li>하드코딩된 의존성 사용</li>
<li>종속성 주입(DI)사용</li>
<li>서비스 로케이터 사용</li>
<li>DI컨테이너 사용</li>
</ul>
<h3 id="하드코딩된-종속성-사용하기">하드코딩된 종속성 사용하기</h3>
<p>어플리케이션이 주로 자신의 상태 유지 모듈을 연결하기 위해 하드코딩된 종속성을 사용하는 경우 이 플러그인 유형을 사용한다. 이런 경우 플로그인이 node_modules 디렉터리 밑에 있는 패키지에 있다면, 메인 어플리케이션의 서비스를 사용하기 위해 상위 패키지에 액세스 할 수 있어야 한다. 두 가지 방법이 있다.</p>
<ul>
<li>require()를 사용하여 상대 또는 절대 경로를 사용하여 어플리케이션 루트를 탐색한다.</li>
<li>부모 어플리케이션 모듈의 require()를 참조하여 사용한다. 일반적으로 이 모듈이 플러그인을 인스턴스화한다. 이렇게 하면, 플러그인이 아닌 부모 어플리케이션에서 호출된 것처럼 require()를 사용하여 어플리케이션의 모든 서비스에 쉽게 액세스할 수 있다.</li>
</ul>
<p>첫 번째 기술은 패키지가 메인 어플리케이션의 위치를 알고 있다고 가정한다.<br>
두 번째 패턴은 패키지의 위치에 상관없이 사용될 수 있다.</p>
<p>플러그인을 빌드하려면 먼저 node_modules 디럭테리에 authsrv-plugin-logout이라는 새로운 패키지를 만들어야 한다. 패키지를 설명하는 최소한의 package.json을 만들고 필수 매개변수를 채워야 한다.</p>
<blockquote>
<p>node_modules/authsrv-pluginlogout/의 파일들<br>
package.json<br>
index.js</p>
</blockquote>
<p>index.js의 첫 줄이 차이를 만든다. 플로그인을 로드하는 부모 모듈의 require()함수에 대한 참조를 얻어 require를 사용하므로 app.js에서 모듈을 로드하는 것처럼 쓸 수 있다.</p>
<p>authService.login 에서는 프록시 패턴을 적용하여 토큰디비에 토큰을 추가하는 작업을 수행한다.<br>
먼저 login()메소드에 대한 참조를 저장한 후 프록시 버전 대체를 시작한다.<br>
프록시 함수에서 원래의 로그인 메소드를 호출한다.<br>
원래의 로그인이 오류를 반환하면 콜백에 전달하고, 그렇지 않으면 토큰을 데이터베이스에 저장한다.</p>
<p>비슷한 방식으로 checkToken도 구현한다. 토큰이 데이터베이스에 존재하는지 확인한다.</p>
<p>그 후 logout메소드를 구현한다.</p>
<p>마지막으로 express 서버에 새로운 라우트를 추가하여 웹 서비스를 통해 새로운 기능을 제공한다.</p>
<pre><code>사용법
curl -X POST -d "{""username"": ""alice"", ""password"":""secret""}" http://localhost:3000/login -H "Content-Type: application/json"
curl -X GET -H “Accept: application/json” http://localhost:3000/checkToken?token=&lt;토큰&gt;
curl -X GET -H “Accept: application/json” http://localhost:3000/logout?token=&lt;토큰&gt;
</code></pre>
<p>이를 통해 플러그인 기반의 확장성이 지원하는 장점을 확인하였다.<br>
또한 모듈 위장(impersonation)을 사용하여 다른 패키지에서 메인 어플리케이션의 서비스에 액세스하는 방법을 배웠다.</p>
<p>물론 모듈 위장(impersonation)은 하드코딩된 종속성의 한 형태이며, 장단점을 공유하고 있다. 한편으로는 최소한의 노력과 최소한의 인프라 조건으로 메인 어플리케이션의 모든 서비스에 액세스 할 수 있지만, 다른 한편으로는 서비스의 특정 인스턴스 뿐만 아니라 그 위치와도 밀접한 커플링을 만들어 낸다. 이것은 플러그인이 메인 어플리케이션의 변경과 리팩토리에 더 쉽게 영향을 받도록 한다.</p>
<h3 id="서비스-로케이터를-사용한-서비스-노출">서비스 로케이터를 사용한 서비스 노출</h3>
<p>어플리케이션의 모든 컴포넌트를 해당 플러그인에 노출하려는 경우는 서비스 로케이터가 좋은 선택이다. 그밖에도 플러그인이 서비스 로케이터를 사용하여 자신의 서비스를 어플리케이션 또는 다른 플러그인에 노출할 수 있다는 큰 장점이 있다.</p>
<blockquote>
<p>authsrv-plugin-logout/index_SL.js</p>
</blockquote>
<p>부모 어플리케이션의 서비스 로케이터를 입력받기 때문에, 필요에 따라 모든 서비스에 액세스 할 수 있다.<br>
어플리케이션이 종속성 측면에서 플러그인에 필요한 것이 무엇인지 미리 알 필요가 없다.<br>
이것은 플러그인이 제어하는 확장에서 장점이다.</p>
<p>app.js 모듈을 다음과 같이 수정한다.</p>
<pre><code>const svcLoc = require('./lib/serviceLocator')();
svcLoc.regiser(...);
//..

svcLoc.register('app',app);
const plugin = require('authsrv-plugin-logout');
plugin(svcLoc);

//...
</code></pre>
<p>플러그인이 서비스에 접근할 수 있도록 하기 위해 해당 어플리케이션 모듈 자체를 서비스 로케이터에 등록한다.<br>
플러그인을 require한다.<br>
서비스 로케이터를 인자로 제공하여 플러그인의 메인 함수를 호출한다.</p>
<h3 id="di를-사용한-서비스-공개">DI를 사용한 서비스 공개</h3>
<p>DI를 사용하여 서비스에 플러그인을 적용하는 것은 쉽다!<br>
또한 DI는 플러그인와 공유되는 것을 보다 잘 제어할 수 있기 때문에, 어플리케이션이 제어하는 확장을 지원하고자 할 경우 이상적인 선택이 된다.<br>
DI를 사용하여 logout 플러그인을 리팩토링해보자.</p>
<blockquote>
<p>pluginDIapp.js<br>
index_DI.js</p>
</blockquote>
<p>서비스 로케이터 대신 플러그인에서 사용하는 인자들을 팩토리로 주입하면 된다.</p>
<p>부모 어플리케이션에서</p>
<pre><code>require('authsrv-plugin-logout')(app, authService, db);
</code></pre>
<p>를 추가하기만 하면 된다.</p>
<p>하드 코딩된 종속성을 사용하던, 서비스 로케이터로부터 인스턴스를 가져오던, 부모 어플리케이션에서 서비스를 연결하는 방법에 상관없이 인스턴스를 가져올 수 있다.<br>
따라서, DI는 유연한 패턴으로 사용할 수 있다.<br>
DI는 플러그인에 일련의 서비스를 제공하는 가장 깔끔한 방법이면서 공개되는 내용을 제어하기 위한 최상의 수준을 제공하여 과도한 확장에 대해 정보 은닉이 쉽다.<br>
그러나 메인 어플리케이션에서 플러그인이 필요로 하는 서비스가 무엇인지 항상 알 수는 없기 때문에 장점이 곧 단점이다.<br>
그래서 우리는 비실용적으로 모든 서비스를 주입하거나, 부모 어플리케이션의 기본적인 핵심 서비스와 같은 일부만 주입하도록 할 수도 있다.</p>
<h3 id="di컨테이너를-사용한-서비스-노출">DI컨테이너를 사용한 서비스 노출</h3>
<p>app.js에 다음과 코드를 추가하여 DI컨테이너 기반의 서비스를 그대로 이용할 수 있다.</p>
<pre><code>//initialize the plugin

diContainer.inject(require('authsrv-plugin-logout'));
</code></pre>
<p>이렇게 하면 플러그인은 부모 어플리케이션이 알 필욕 없는 일련의 자체 의존성들을 require할 수 있다. 모든 연결은 DI컨테이너에 의해 자동으로 재수행된다.<br>
DI컨테이너를 사용하면 각 플러그인이 잠재적으로 어플리케이션의 모든 서비스에 대해 액세스할 수 있으므로 정보 은닉과 사용 또는 확장할 수 있는 것들에 대한 통제가 줄어든다. 이 문제에 대한 해결책은 플로그인에 공개하려느 서비스만 등록하는 별도의 DI 컨테이너를 만드는 것이다. 이렇게 하면 각 플러그인이 메인 어플리케이션에서 볼 수 있는 것들을 제어할 수 있다.<br>
이것은 DI컨테이너가 캡슐화와 정보 은닉 측면에서 매우 좋은 선택이 될 수 있음을 보여준다.</p>
<h1 id="요약">7.4 요약</h1>
<p>Node.js의 싱글톤과 인스턴스에 대한 가장 일반적인 개념을 익히고, 하드코딩된 의존성, DI 및 서비스 로케이터를 사용하여 모듈을 연결하는 방법을 배웠다.<br>
인증 서버를 예제로 각 기법을 연습하여 각 접근 방식의 장단점을 파악했다.</p>
<p>어플리케이션이 플로그인을 지원하는 방법도 배웠다.<br>
가장 중요한 것은 플러그인을 메인 어플리케이션에 연결하는 방법들이다.<br>
플러그인이 메인 어플리케이션에 적절한 서비스에 액세스하는 것이 중요하고, 그것은 기능에 많은 영향을 준다.</p>
<p>이 장을 통해 어플리케이션에서 얻고자 하는 디커플링, 재사용성 및 단순성의 수준을 위한 최상의 접근 방법을 선택하는 것이 더 이상은 어렵지 않을 것이다.<br>
동일한 어플리케이션에서 둘 이상의 패턴을 사용할 수도 있다. 하드코딩된 종속성을 주요 기법으로 사용하면서, 플러그인 연결과 관련해서 서비스 로케이터를 사용할 수도 있다.</p>

