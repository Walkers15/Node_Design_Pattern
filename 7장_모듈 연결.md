---


---

<h1 id="장-모듈-연결">7장 모듈 연결</h1>
<p>Node.js의 모듈 시스템은 코드를 자체적인 독립된 유닛으로 구성할 수 있는 네이티브적인 방법이 부족한 자바스크립트 언어와의 격차를 메워 준다.<br>
가장 큰 장점 중 하나는, 간단하고 강력한 접근 방식은 require()를 사용하여 이들 모듈들을 서로 연결할 수 있다는 것이다.</p>
<p>노드 개발자들이 자주 접하는 질문 중 하나는<br>
“모듈 X의 인스턴스를 모듈 Y로 전달하는 가장 좋은 방법은 무엇입니까?”<br>
다.<br>
그 만큼 노드에서 모듈을 연결하는 방법은 Node.js의 디자인패턴 중 중요한 질문이라고 할 수 있다.<br>
따라서 사람들은 모듈들을 서로 연결하는 더 친숙한 방법을 찾기 위해 싱글톤, 종속성 삽입까지 사용하기도 한다.<br>
<strong>모듈 연결(wiring)</strong> 기술이 Node.js에서 가장 논란의 여지가 있으며 독창적인 주제 중 하나라는 것은 놀라운 일이 아니다.</p>
<p>이 영역에 영향을 미치는 많은 이론이 있지만, 명확한 정답은 없다.<br>
실제로 모든 접근법에는 장단점이 있으며, 종종 동일한 APP에서 여러 가지 접근법을 사용하거나 다른 이름으로 변경되거나 커스터마이징 되어 사용된다.</p>
<p>이 장에서는 모듈 연결에 대한 접근법을 분석하고, 장단점을 강조한다.<br>
또한 단순성, 재사용성 및 확장성의 기준에 따라 합리적인 선택과 혼합을 할 수 있도록 한다.<br>
가장 중요한 패턴들은 아래와 같다.</p>
<ul>
<li>하드코딩된 종속성</li>
<li>의존성 주입(Dependency Injection)</li>
<li>서비스 로케이터</li>
<li>의존성 주입 컨테이너</li>
</ul>
<p>그런 다음 밀접하게 관련된 문제로 플러그인을 연결하는 방법을 본다.<br>
플러그인이 별도의 패키지로 배포되는 경우 App의 내용에 따라 조금씩 차이가 있으며, 자체적인 문제점이 존재한다.<br>
플러그인이 가능한 구조를 만드는 주요한 기술을 먼저 배우고, 이 플러그인을 메인 App의 흐름에 통합하는 방법을 살펴보자.</p>
<h1 id="모듈과-의존성">7.1 모듈과 의존성</h1>
<p>모든 최신 App은 여러 컴포넌트들을 결합한 결과이며, 어플리케이션이 커짐에 따라 이러한 컴포넌트를을 연결하는 방식이 승패 요건이 된다.<br>
확장성과 같은 기술적 측면과 관련된 문제일 뿐만 아니라 시스템을 이해하는 방식에 대한 인식도 있다.<br>
얽힌 <strong>종속성 그래프</strong>는 골칫거리가 되며, 프로젝트의 <strong>기술적 부채</strong>가 된다.</p>
<p>최악의 경우 컴포넌트들이 너무 밀접하게 연결되어 있어, 리팩토링이나 어플리케이션 전체 부분을 완전히 다시 작성하지 않고는 기능을 추가하거나 변경할 수 없게 된다. 따라서, 처음부터 좋은 균형을 찾는 것이 큰 차이를 만들 수 있다.</p>
<p>노드는 어플리케이션의 컴포넌트를 구성하고 묶는 유용한 도구들을 제공하는데, 이 모듈이 CommonJS 모듈 시스템(module system)이다. 그러나 모듈 시스템만으로는 성공을 보장할 수 없다. 다른 한편으로는 클라이언트 모듈과 종속성 사이에 간접적인 수준의 참조를 추가하여 적절하게 사용하지 않으면, 더 엄격한 결합을 만들게 될 수 있다.</p>
<h2 id="node.js의-가장-일반적인-종속성">7.1.1 Node.js의 가장 일반적인 종속성</h2>
<p>소프트웨어 아키텍처에서는 컴포넌트의 동작이나 구조에 영향을 미치는 엔티티, 상태 또는 데이터 형식을 <strong>종속성</strong>으로 간주할 수 있다.<br>
예를 들어, 어떤 컴포넌트가 다른 컴포넌트에서 제공하는 서비스를 사용하거나, 시스템의 특정 상태에 의존하거나, 다른 컴포넌트와 정보를 교환하기 위해 통신 프로토콜을 구현하는 등을 이유로 들 수 있다.<br>
종속성의 개념은 광범위하며, 때로는 평가하기도 어렵다.</p>
<p>하지만 Node.js에서는 가장 일반적이며 쉽게 식별할 수 있는 필수 유형의 종속성을 바로 식별해낼 수 있다.<br>
모듈(Module)은 코드를 구조화하는 데 필요한 기본적인 메커니즘이다. 어플리케이션의 다양한 요소들을 <strong>그룹화</strong>하는데 제대로 사용한다면, 이점이 많다. 실제 모듈의 속성은 다음과 같이 요약할 수 있다.</p>
<ul>
<li>모듈은 보다 집중적이기 때문에, 더 가독성이 높고 이해하기 쉬움</li>
<li>별도의 파일로 표현하기 때문에 쉽게 식별할 수 있음</li>
<li>모듈을 다른 App보다 쉽게 재사용할 수 있음.</li>
</ul>
<p>모듈은 정보 은닉을 수행하는 완벽한 수준의 세분화된 단위를 나타내며(Module.exports) 컴포넌트의 공개 인터페이스만을 노출하고 나머지는 은닉하는 효과적인 메커니즘을 제공한다.<br>
그러나 단순히 어플리케이션이나 라이브러리의 기능을 여러 모듈에 분산시키는 것만으로는 성공적인 디자인이라 할 수 없다. 잘못된 사용 중 한 가지는 독특한 모놀리식(monolithic) 개체를 만들어 내는 것이며, 그 상태에서 모듈을 제거하거나 교체하는 것이 아키텍처의 대부분을 뒤흔들게 된다.<br>
코드를 모듈로 구성하는 방식과 모듈을 서로 연결하는 방식이 전략적인 역할을 하며, 소프트웨어 설계의 모든 문제와 마찬가지로 여러 가지 평가 항목들 사이에서 <strong>적절한 균형</strong>을 찾아야 한다.</p>
<h2 id="응집력과-결합력">7.1.2 응집력과 결합력</h2>
<p>모듈을 만들 때 가장 중요한 두 가지 특성은 <strong>응집력과 결합력이 균형</strong>을 이루는 것이다.<br>
이것들은 소프트웨어 아키텍처에서 모든 유형의 컴포넌트 또는 하위 시스템에 적용될 수 있으므로 노드 모듈을 구축할 때 지침으로 사용할 수 있다.</p>
<p>이 두 속성은 다음과 같이 정의할 수 있다.</p>
<h4 id="응집력cohesion">응집력(Cohesion)</h4>
<p>컴포넌트 기능 간의 <strong>상관관계</strong>에 대한 측도이다.<br>
예를 들어 단 한가지의 작멉한 하는 모듈은, 모듈의 모든 부분이 그 하나의 단일 업무에서만 역할을 할 경우 높은 응집력을 가진다고 할 수 있다. <em>saveProduct(), saveInvoice(), saveUser()</em> 등과 같이 모든 유형의 객체를 데이터베이스에 저장하는 함수를 가진 모듈은 낮은 응집력을 가진다.</p>
<h4 id="결합력coupling">결합력(Coupling)</h4>
<p>구성 요소가 시스템이나 다른 구성 요서에 얼마나 <strong>의존</strong>하는지에 대한 측도이다.<br>
예를 들어, 모듈이 다른 모듈의 데이터를 직접 읽거나 수정하면, 결합력이 높은 모듈이다.<br>
또한 전역이나 공유된 상태를 통해 상호작용하는 모듈들은 밀접한 결합이다.<br>
반면에 매개 변수 전달을 통해서만 두 모듈이 통신한다면 느슨한 결합이라고 할 수 있다.</p>
<p>바람직한 시나리오는 <strong>높은 응집력</strong>과<strong>느슨한 결합</strong>을 가지는 것이다.<br>
이는 일반적으로 재사용 가능하고 확장 가능한 모듈을 뜻한다.</p>
<p><strong>왠만하면 매개변수만 가지고 자기 안에서 끝내는 것을 목표로 하자!</strong><br>
<strong>=&gt; 모듈 단위가 작아질 수 밖에 없음</strong></p>
<h2 id="상태-저장stateful-모듈">7.1.3 상태 저장(Stateful) 모듈</h2>
<p>자바스크립트에서는 모든 것이 하나의 <strong>객체</strong>이다. 인터페이스나 클래스와 같은 추상적이 개념이 없다.<br>
동적 타이핑은 이미 <strong>인터페이스</strong>(또는 <strong>정책</strong>, 패턴)를 <strong>구현</strong>(또는 <strong>세부사항</strong>)에서 분리하는 자연스러운 매커니즘을 제공한다. 그것이 6장에서 본 디자인 패턴 중 일부가 기존 패턴과 비교해서 매우 다르면서 단순해 보이는 이유 중 하나이다.</p>
<p>그러나 자바스크립트에서는 인터페이스와 구현을 분리할 때 작은 문제점을 가지고 있다.<br>
이미 간단하게 노드 모듈 시스템을 사용함으로써 특정 구현체와의 하드코드된 관계를 볼 수 있었다.<br>
정상적인 상태에서는 이 문제가 발생하지 않지만, require()를 사용하여 DB핸들, HTTP 서버 인스턴스, 서비스 인스턴스 같은 상태 저장(stateful) 인스턴스를 외부에 익스포트하는 모듈을 로드하거나 상태 저장이 아닌(stateless) 일반 객체를 익스포트하는 모듈을 로드할 경우, 실제 싱글톤과 매우 유사한 것을 참조하게 됨으로써 주의사항과 장단점을 얻게 된다.</p>
<h3 id="node.js의-싱글톤-패턴">Node.js의 싱글톤 패턴</h3>
<p>Node를 처음 사용하는 사람들은 대부분의 경우 어플리케이션의 다양한 모듈 간에 <strong>단일한 인스턴스</strong>를 공유하기 위한 방법으로 싱클톤 패턴을 선호하게 되고, 어떻게 싱글톤 패턴을 올바르게 구현할 수 있는지를 혼란스러워 한다. 그러나 노드의 대답은 우리의 생각보다 쉽다. 단순히 module.exports를 사용하여 인스턴스를 내보내는 것만으로 이미 싱글톤(Singleton)패턴과 비슷한 것을 얻을 수 있다.</p>
<p>예를 들어 다음과 같은 코드를 생각해 보자.</p>
<pre><code>module.exports = new Database('my-app-db');
</code></pre>
<p>단순히 DB에서 새로운 인스턴스를 내보내는 것만으로도 현재 패키지 내에서 이미 db모듈의 인스턴스가 <strong>하나만 있다고 가정할 수 있다.</strong> 우리가 이미 알다시피 Node.js는 require()의 첫 번째 호출 이후에 모듈을 <strong>캐시</strong>할 것이고, 이후의 호출에서 다시 실행하지 않고 <strong>캐시된 인스턴스를 반환</strong>하기 때문에 가능하다.</p>
<pre><code>const db = require('./db');
</code></pre>
<p>단순히 다음과 같은 코드로 앞에서 정의한 db모듈의 공유 인스턴스를 가져올 수 있다.</p>
<p>이 과정에는 유의사항이 있다. 모듈은 전체 경로를 검색 키로 사용하여 캐시되므로, <strong>현재 패키지 내에서만 싱글톤이 보장된다.</strong><br>
각 패키지가 자신의 node_modules 디렉토리 내에 일련의 자신만의 종속성들을 가질 수 있으므로, 다음과 같은 상황이 발생할 수 있다.</p>
<pre><code>#package.json
{
	"name": "mydb"
	"main": "db.js"
}
</code></pre>
<p>아래과 같은 종속성 트리를 생각해보자.</p>
<pre><code>app/
	ㄴnode_modules
		ㄴpackageA
			ㄴnode_modules
				ㄴmydb
		ㄴpackageB
			ㄴnode_modules
				ㄴmydb
</code></pre>
<p>packageA와 packageB는 모두 mydb 패키지에 종속성을 가지고 있다.<br>
app패키지는 packageA와 packageB에 종속성을 가진다.<br>
실제로 packageA와 packageB는 다음과 같은 명령을 사용해 db인스턴스를 로드할 것이다.</p>
<pre><code>const db = require(mydb);
</code></pre>
<p>이렇게 하면, 같은 mydb지만 패키지에 따라 다른 인스턴스로 해석되기 때문에 packageA와 packageB는 실제로 싱글톤처럼 보이는 두 개의 서로 다른 인스턴스를 로드한다.</p>
<p>이 시점에서 우리는 <code>global.db = new Database('my-app-db');</code>와 같이 선언하지 않는 이상,<br>
앞서 설명된 패턴은 노드 내에 존재하지 않는다고 할 수 있다.</p>
<p>이렇게 하면 인스턴스가 유일한 패키지가 될 뿐 아니라, 비단 한 패키지 뿐만 아니라 전체 어플리케이션에 공유될 것이다. 이것은 <strong>절대 추천되는 상황이 아니다.</strong> 또한 굳이 이렇게 할 필요도 없다.</p>

