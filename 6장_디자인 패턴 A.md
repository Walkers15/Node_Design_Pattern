---


---

<h1 id="장-디자인-패턴">6장 디자인 패턴</h1>
<p>먼저 널리 알려진 객체지향 패턴 집합으로 “전통적인 디자인 패턴(“GoF 디자인 패턴”)” 이라고 알려진 패턴을 살펴본다.<br>
또한 그 생태계 내에서 생성된 “덜 전통적인” 디자인 패턴도 살펴본다.<br>
이 장에서 살펴볼 패턴은 다음과 같다.</p>
<ul>
<li>팩토리</li>
<li>공개 생성자</li>
<li>프록시</li>
<li>데코레이터</li>
<li>어댑터</li>
<li>전략</li>
<li>상태</li>
<li>템플릿</li>
<li>미들웨어</li>
<li>명령</li>
</ul>
<p>참고 링크_<a href="https://medium.com/@chrisjune_13837/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%83%81%EC%86%8D-7c275edaa9e6">자바스크립트에서의 상속</a></p>
<h1 id="팩토리factory">6.1 팩토리(Factory)</h1>
<h2 id="객체를-생성하기-위한-제너릭-인터페이스">6.1.1 객체를 생성하기 위한 제너릭 인터페이스</h2>
<p>실제로, new연산자 혹은 Object.create()를 사용하여 프로토타입에서 직접 새 객체를 만드는 대신 팩토리를 호출하면 여러 면에서 훨씬 편리하고 유연하다.</p>
<p>무엇보다 먼저 팩토리는 <strong>객체 생성을 구현과 분리할 수 있게 해준다.</strong><br>
팩토리 내에서 클로저를 활용하고, 프로토타입과 new연산자, Object.create()를 사용하여 새로운 인스턴스를 만들거나 또는 특정 조건에 따라 다른 인스턴스를 반환할 수도 있다.<br>
팩토리의 소비자는 인스턴스 생성이 수행되는 방법에 대해서는 알 필요가 없다.<br>
new 연산자를 사용하면 객체 하나를 생성하는데 한 가지 특정한 방법으로만 코드를 바인드할 수 있으나 JS에서는 더 유연하고 거의 제약이 없을 수 있다.</p>
<pre><code>function createImage(name){
	return new Image(name);
}
const image = createImage('photo.jpeg');
</code></pre>
<p>createImage() 팩토리는 단순히 new 연산자를 사용할 뿐이므로, 직접 new연산자를 사용하여 Image클래스를 인스턴스화할 수도 있다.</p>
<pre><code>const image = new Image(name)
</code></pre>
<p>new를 사용하면 특정 유형의 객체만을 코드에 바인딩할 수 있다.<br>
팩토리는 대신 더 많은 유연성을 제공할 수 있으며, 또한 생성된 객체의 생성자를 노출시키지 않고 객체를 확장하거나 수정하지 <strong>못하도록 한다.</strong>(캡슐화)</p>
<p>노드에서는 각 생성자를 비공개로 유지하면서 팩토리만 내보내는 방법으로 이 작업을 수행할 수 있다.</p>
<pre><code>function createImage(name){
	if(name.match(/\.jpeg$/)){
		return new JpegImage(name);
	}else if(name.match(/\.gif$/)){
		return new GifImage(name);
	} else if(name.match(/\.png$/)){
		return new PngImage(name);
	}else{
		throw new Exception('Unsupported format');
	}
}
</code></pre>
<h2 id="캡슐화를-강제하기-위한-메커니즘">6.1.2 캡슐화를 강제하기 위한 메커니즘</h2>
<p>팩토리는 클로저 덕분에 캡슐화 메커님즈으로도 사용할 수 있다.<br>
JS에는 접근 수준 지정자(public, private)가 없으므로, 캡슐화를 적용하는 유일한 방법은 함수 범위(function scope)와 클로저를 사용하는 것이다.<br>
예시를 보자.</p>
<pre><code>function createPerson(name){
	//person 객체의 인터페이스(메소드)를 통해서만 조작 가능
	//외부에서 접근이 불가능함(private)
	const privateProperties = {};
	
	//팩토리에 의해 반환되는 공용 인터페이스
	const person = {
		setName: name =&gt; {
			if(!name) throw new Error('A person must have a name');
			privateProperties.name = name;
		},
		getName: ()=&gt;{
			return privateProperties.name;
		}
	};
	
	person.setName(name);
	return person;
}
</code></pre>
<p>위 코드에서 클로저를 사용하여 두 개의 객체를 생성한다.<br>
우리는 위 코드에서 person.name이 비어있을 수 없도록 한다. 이것은 name이 단순히 person의 속성일 경우에는 강제할 수 없다.</p>
<blockquote>
<p>WeakMap 등을 통해 private멤버를 생성할 수도 있다. <a href="https://developer.mozilla.org/en-US/docs/Archive/Add-ons/Add-on_SDK/Guides/Contributor_s_Guide/Private_Properties">참고 링크</a></p>
</blockquote>
<h2 id="간단한-코드-프로파일러-작성하기">6.1.3 간단한 코드 프로파일러 작성하기</h2>
<blockquote>
<p>profiler.js<br>
profiler_luncher.js</p>
</blockquote>
<p>프로파일링 세션을 시작시키는 start()메소드<br>
세션을 종료하고 실행 시간을 콘솔에 기록하는 end() 메소드</p>
<p>어플리케이션이 프로덕션 모드일 경우, 비어있는 start()와 stop() 메소드가 있는 모의(Mock)객체를 반환함.</p>
<p>JS의 동적형 결정(dynamic typing)덕분에 한편으로는 new 연산자로 생성된 객체를, 다른 편으로는 간단한 객체 리터럴을 반환할 수 있다.</p>
<p>이것은 <strong>덕 타이핑(duck typing)</strong> 이라고도 알려져 있다.</p>
<p>팩토리를 사용함으로써 객체의 생성을 분리하고, 입맛대로 attribute를 적용할 수 있다.</p>

