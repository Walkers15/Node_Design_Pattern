---


---

<h1 id="장-디자인-패턴-b">6장 디자인 패턴 B</h1>
<h1 id="전략strategy">6.6 전략(Strategy)</h1>
<p>전략 패턴은 컨텍스트(Context)라 불리는 객체를 사용하여 변수 부분을 상호 교환 가능한 개별 전략이라는 객체들로 추출함으로써 연산 로직의 변형을 지원한다, 컨텍스트는 일련의 알고리즘의 공통 로직을 구현하는 반면, 개별 전략은 입력값, 시스템 구성 혹은 사용자 기본 설정 같은 사양한 요소들을 컨텍스트(context)의 동작에 적용할 수 있도록 변경 가능한 부분을 구현한다.</p>
<p>개별 전략들은 대게 솔루션 제품군에 속하며, 이들은 모두 동일한 인터페이스를 구현한다. 이 인터페이스는 컨텍스트에서 알 수 있는 인터페이스여야 한다.</p>
<p><strong>컨텍스트에서 변수를 개별 전략이라는 객체들로 추출!</strong></p>
<p>즉, 컨텍스트는 다양한 전략들을 마치 교체 가능한 부품처럼 교체하고 연결시킬 수 있다.<br>
자동차를 상상해 보자, 타이어는 서로 다른 도로 상태에 차를 적응시키기 위한 전략이라고 생각할 수 있다. 우리는 체인 덕분에 겨울철 타이어를 눈 덮인 도로에 알맞게 맞출 숭 있으며, 장거리 여행의 경우에는 고속도로를 주행하기 위한 고성능 타이어로 맞출 수도 있다.<br>
생각해 보면, 우리는 환경에 맞추기 위해 차량 전체를 변경하지 않으며, 가능한 모든 도로를 운행할 수 있도록 바퀴가 8개 달린 자동차를 만들지도 않는다.</p>
<p>전략 패턴을 제대로 이해하면, 알고리즘 내에서 문제를 분리하는 데 도움이 될 뿐만 아니라, 더 나은 유연성을 제공하여 동일한 문제의 다양한 변형에 적용할 수 있다.</p>
<p>알고리즘의 변형에 전략을 적용하는 경우는, 알고리즘 내에서 복잡한 조건문이 필요하거나 같은 유형의 다른 알고리즘을 함께 혼합하여 사용하는 경우이다.</p>
<p>전자상거래 웹 사이트의 온라인 주문을 나타내는 Order라는 객체가 있다고 가정하자. 객체에는 pay()라는 메소드가 있고, 이 메소드는 주문을 마무리하고 사용자의 돈을 온라인 상점으로 전송한다.<br>
사용자가 돈을 지불할 때는 if…else 문을 사용하여 선택한 지불 옵션을 기반으로 작업을 하게 할 수도 있다. 또한 사용자가 선택한 특정 지불 게이트웨이에 대한 로직을 구현하는 전략 객체에 지불을 위암할 수도 있다. 즉, pay를 Order 내에서 처리하지 않는 것이다.</p>
<h2 id="다중-형식의-환경설정-객체">6.6.1 다중 형식의 환경설정 객체</h2>
<p>데이터베이스 URL, 서버의 리스닝 포트 등과 같은 어플리케이션에 의해 사용되는 일련의 환경설정 파라미터들을 보관하는 Config 객체를 생각해 보자.<br>
Config객체는 이러한 파라미터에 접근할 수 있는 간단한 인터페이스를 제공해야 하며, 파일과 같은 영구 저장소를 사용하여 환경설정을 가져오거나 내보내는 방법도 제공해야 한다.<br>
JSON, INI, YMAL과 같이 구성을 저장할 수 있는 다른 형식을 지원할 수도 있어야 한다.<br>
전략 패턴에 대해 배운 것을 적용함으로써 Config 객체가 구성을 직렬화 및 비직렬화 할 수 있는 함수를 이용하여 Config 객체의 변수 부분을 바로 식별할 수 있다. 이것이 우리의 전략이 된다.</p>
<blockquote>
<p>config.js</p>
</blockquote>
<p>위 코드에서는 환경설정 데이터를 인스턴스 변수(this.data)에 캡슐화한 다음, 점 경로 표기법(property.subProperty 등)을 사용하여 환경설정 속성에 접근할 수 있는 set(), get()메소드를 제공한다.<br>
점 경로 표기법은 npm 라이브러리에 의해 사용되는데, 객체 경로라고 한다.<br>
데이터를 분석하고 직렬화하는 알고리즘을 나타내는 변수 strategy를 생성자에서 입력으로 받는다.</p>
<p>이전의 코드에서 파일로부터 환경설정을 읽을 때, 우리는 deserialization 작업을 strategy에 위임한다. 그리고 환경설정을 파일에 저장할 때, strategy를 사용하여 환경절성을 시리얼라이즈한다. 이 간단한 디자인은 Config 객체가 데이터를 로드하고 저장할 때 다른 파일 형식을 지원할 수 있게 해준다.</p>
<p>이제 이것을 설명하기 위해 strategies.js라는 파일에 몇 가지 strategy를 만들어 보자.</p>
<blockquote>
<p>strategies.js</p>
</blockquote>
<p>역직렬화(Deserialize), 직렬화(Serialize)</p>
<p>위에서 정의한 방식보다, 다음과 같은 유용한 접근법도 있을 수 있다.</p>
<ul>
<li>
<p>Serialize를 위한 전략과 Deserialize를 위한 전략 쌍을 생성한다. 이렇게 하면 한 형식을 읽이서 다른 형식으로 저장할 수 있다.</p>
</li>
<li>
<p>제공된 파일의 확장자에 따라 동적으로 전략을 선택한다 : Config는 파일의 확장자와 Strategy를 쌍으로 담고 있는 맵을 보관하고, 확장자에 따른 적절한 알고리즘을 선택하는데 맵을 사용한다.</p>
</li>
</ul>
<p>또한 패턴 자체의 구현은 매우 간단할 수 있다.<br>
가장 단순하게, context와 strategy모두 간단한 함수일 수 있다.</p>
<pre><code>function context(strategy)
</code></pre>
<h2 id="실전에서는-어떻게-사용되는가">6.6.2 실전에서는 어떻게 사용되는가</h2>
<p>Passport.js는 웹 서버의 여러 인증 체계를 지원하는 노드의 인증 프레임워크다. Passport는 인증 프로세스 중에 필요한 공통적인 논리와 변경할 수 있는 부분, 즉 실제 인증 단계를 분리하는 데 전략 패턴을 사용한다.</p>
<h1 id="상태state">6.7 상태(State)</h1>
<p>State는 컨텍스트의 상태에 따라 전략이 변경되는 <strong>전략 패턴의 변형</strong>이다.<br>
이전 섹션에서는 사용자 기본 설정, 환경설정 매개변수 및 제공된 입력 같은 다양한 변수를 기반으로 개별 전략을 선택했다.<br>
이 선택이 완료되면 컨텍스트의 나머지 수명 동안 전략은 변경되지 않는다.</p>
<p>대신, 상태(State)패턴에서 전략은 동적이며, 컨텍스트의 수명 동안 변경될 수 있다.<br>
상태 전이는 컨텍스트 객체, 클라이언트 코드 또는 상태 객체 자체에 의해 시작되고 제어될 수 있다.<br>
상태 객체 자체에 의해 시작되고 제어되는 옵션은 일반적으로 컨텍스트가 모든 가능한 상태와 이들 사이를 전환하는 방법에 대해 <strong>알 필요가 없으므로</strong>(시킬 때 시키는 거 하면 됨). 유연성 및 디커플링 측면에서 최상의 결과를 제공한다.</p>
<h2 id="기본적인-fail-safe-socket-구현하기">6.7.1 기본적인 fail-safe-socket 구현하기</h2>
<p>서버와의 연결이 끊어졌을 때 실패하지 않는 클라이언트 TCP 소켓을 만들어 보자.<br>
대신 서버가 오프라인 상태일 동안 보낼 모든 데이터를 대기열(queue)에 넣고 연결이 다시 설정되자마자 다시 보낸다.<br>
우리는 이 소켓을 간단한 모니터링 시스템의 컨텍스트 내에서 사용하려 한다.<br>
이 모니터링 시스템에는 정기적으로 일련의 컴퓨터 리소스 사용률에 대한 통계를 보낸다고 가정한다.</p>
<blockquote>
<p>failsafeSocket.js<br>
onlineState.js<br>
offlineState.js<br>
server.js<br>
client.js</p>
</blockquote>
<h1 id="템플릿">6.8 템플릿</h1>
<p>전략 패턴과 공통점이 많은 패턴이다. 템플릿은 알고리즘의 골격을 나타내는 추상 의사 클래스(abstract pseduo class)를 정의하는 것으로 구성된다. 이 클래스의 일부 단계는 정의되지 않은 채로 있는다.<br>
서브 클래스는 <strong>템플릿 메소드</strong>라는 누락된 단계를 구현하여 알고리즘의 비어있는 부분을 채울 수 있다.<br>
이 패턴은 유사한 알고리즘의 모든 변형을 패밀리 클래스로 정의하는 것에 목적을 둔다.</p>
<p>자바스크립트에서는 메소드가 undefined인 채로 남아 있거나 메소드가 구현되어야 한다는 것을 나타내기 위해. 항상 예외를 발생시키는 throw 함수에 할당한다. 템플릿 패턴은 상속이 구현의 핵심 부분이기 때문에, 우리가 지금까지 본 다른 패턴보다 더 고전적인 객체지향으로 간주될 수 있다.</p>
<p>템플릿(Template)과 전략(Strategy)의 목적은 매우 유사하지만, 두 가지의 주요 차이점은 구조와 구현에 있다.<br>
둘 다 공통 부분을 재사용하면서 알고리즘의 일부분을 변경할 수 있지만, 템플릿은 구체적인 클래스가 정의되는 순간 알고리즘이 완성된다.</p>
<p>이러한 가정하에 템플릿 패턴은 <strong>미리 패키지화된 알고리즘의 변형</strong>을 만들어야 하는 상황에 더 적합할 수 있다.<br>
그러므로 우리는 각 유스케이스에 대해 여러 가지 장단점을 고려해야 한다.</p>
<h2 id="환경설정-관리자-템플릿">6.8.1 환경설정 관리자 템플릿</h2>
<p>전략(Strategy)과 템플릿(Template)의 차이를 이해하기 위해, 템플릿을 사용하여 Config객체를 다시 구현해 보자.</p>
<blockquote>
<p>ConfigTemplate.js<br>
jsonConfig.js<br>
templateConfigTest.js</p>
</blockquote>
<p>함수명 시작 부분에 있는 밑줄은 내부에서만 사용할 수 있는 보호된(Protect) 메소드를 표시하기 위한 간편한 방법이다.<br>
자바스크립트에서는 abstract를 사용할 수 없기 때문에, 메소드를 단순히 <strong>스텁</strong>(내용 없는 메소드)으로 정의하고 싶을 때 예외를 던진다.</p>
<h2 id="실전에서는-어떻게-사용되는가-1">6.8.2 실전에서는 어떻게 사용되는가</h2>
<p>5장 스트림 코딩에서 다른 스트림 클래스를 확장하여 사용자 정의 스트림을 구현할 때 이미 보았듯, 구현하고자 하는 스트림 클래스에 따라 _write(), _read(), _transform() 또는 _flush() 메소드를 구현하였다. 새로운 커스텀 스트림 생성을 위해 특정 <strong>추상 스트림 클래스</strong>를 상속받아 템플릿 메소드 구현을 제공했었다.</p>
<h1 id="미들웨어middleware">6.9 미들웨어(Middleware)</h1>
<p>Node.js의 가장 특징적인 패턴 중 하나이다.<br>
엔터프라이즈 아키텍쳐 영역에서 미들웨어는 낮은 수준의 메커니즘을 추상화하는데 도움이 되는 다양한 소프트웨어 제품군을 나타내는 용어이다.<br>
이런 맥락에서 미들웨어라는 용어는 CORBA, Spring, JBoss 같은 주제를 떠올리게 한다.<br>
그러나 보다 일반적인 의미에서 하위 서비스와 어플리케이션 사이의 접착제처럼 작용하는 모든 소프트웨어 계층을 정의할 수도 있다.(말 그대로 중앙에 있는 소프트웨어)</p>
<h2 id="미들웨어로서의-express">6.9.1 미들웨어로서의 Express</h2>
<p>Express는 노드 세계에서 미들웨어라는 용어를 대중화하여 특정 디자인 패턴에 바인딩하였다.<br>
실제로 Express에 있어서 미들웨어는 파이프라인에서 구성되고 들어오는 HTTP 요청 및 응답의 처리를 책임지는 일련의 서비스인 일반적인 함수들을 말한다.</p>
<p>Express는 개밸자에게 많은 권한을 주고 최소화된 웹 프레임워크로 유명하다.<br>
미들웨어 패턴은 개발자가 프레임워크 코어를 확장하지 않고도 현재 어플리케이션에 쉽게 추가할 수 있는 새 기능을 쉽게 만들고 배포할 수 있는 효과적인 전략이다.</p>
<p>Express 미들웨어는 다음과 같은 특징을 가진다.</p>
<pre><code>function(req, res, next){ ... }
</code></pre>
<p>여기서 req는 request, 들어오는 HTTP요청이다. res(response)는 응답이며, next는 현재 미들웨어가 작업을 완료하고 차례로 파이프라인의 다음 미들웨어를 트리거할 때 호출되는 콜백이다.</p>
<p>Express미들웨어가 수행하는 작업은 다음과 같다.</p>
<ul>
<li>
<p>요청 본문의 구문 분석</p>
</li>
<li>
<p>요청 및 응답 압축 및 해제</p>
</li>
<li>
<p>액세스 로그 생성</p>
</li>
<li>
<p>세션 관리</p>
</li>
<li>
<p>암호화된 쿠키 관리</p>
</li>
<li>
<p><strong>CSRF</strong>(Cross-Site Request Forgery)<br>
이 기능들은 모두 어플리케이션의 주요 기능과는 관련이 없다.<br>
대신 비즈니스 로직에서 실제 요청의 처리만을 집중할 수 있도록 나머지 부분을 지원한다.<br>
기본적으로 이러한 작업은 미들웨어들이 하게 된다.</p>
</li>
</ul>
<h2 id="패턴으로서의-미들웨어">6.9.2 패턴으로서의 미들웨어</h2>
<p>Express에서 미들웨어를 구현하는데 사용된 기술은 사실 새로운 것이 아니며, 실제로 이것은 Interception Filter패턴과 Chain of Responsibility 패턴의 Node.js 판이라 할 수 있다.<br>
좀 더 일반적인 용어로 스트림과 유사한 처리 파이프라인을 나타낸다.<br>
오늘날 노드에서 미들웨어라는 단어는 Express 프레임워크의 경계를 훨씬 넘어서 사용되며, 모든 종류의 데이터에 대한 전처리 및 후처리를 사용하기 위하여 함수의 형태로 처리 단위, 필터 및 핸들러 집합이 비동기 시퀀스의 형태로 연결된 특정 패턴을 나타낸다.</p>
<p>패턴의 핵심 컴포넌트는, 미들웨어 기능을 구성하고 실행하는 데 책임이 있는 미들웨어 관리자다.<br>
패턴의 가장 중요한 구현의 세부 항목은 다음과 같다.</p>
<ul>
<li>
<p>새로운 미들웨어는 use()[app.use()] 함수를 호출하여 등록할 수 있다. 일반적으로 새로운 미들웨어는 파이프라인 끝에 추가할 수 있지만, 중간에 추가해도 상관은 없다.</p>
</li>
<li>
<p>처리를 위해 사로 수신된 데이터의 처리는 비동기 순차 실행의 흐름으로 해당 등록된 미들웨어가 호출된다. 파이프라인의 각 유닛은 이전 유닛의 실행 결과를 입력으로 받는다.</p>
</li>
<li>
<p>각각의 미들웨어는 콜백을 호출하지 않거나 에러를 콜백에 전달함으로써 데이터 처리를 중단할 수 있다. 오류 상황은 대게 오류 처리 전용인 다른 일련의 미들웨어를 실행시킨다.</p>
</li>
</ul>
<p>파이프라인에서 데이터가 처리되고 전파되는 방식에 대한 엄격한 규칙은 없다.<br>
미들웨어 전략에는 또한 다음이 포함된다.</p>
<ul>
<li>
<p>추가 속성 또는 기능을 이용한 데이터 추가</p>
</li>
<li>
<p>데이터를 일련의 처리 결과로 바꾸기</p>
</li>
<li>
<p>데이터의 불변성을 유지하고 처리 결과로 항상 새로운 사본을 변환</p>
</li>
</ul>
<h2 id="ømq용-미들웨어-프레임워크-만들기">6.9.3 ØMQ용 미들웨어 프레임워크 만들기</h2>
<p>ZMQ(ZeroMQ,ØMQ)는 다양한 프로토콜을 사용하여 네트워크를 통해 원자 메시지를 교환하기 위한 간단한 인터페이스를 제공한다. 이것은 성능 면에서 빛을 발하고 기본적인 추상화 집합은 맞춤형 메시징 아키텍쳐의 구현을 용이하게 하기 위해 특별히 만들어졌다.<br>
ZMQ의 인터페이스는 꽤 낮은 수준이다. 메시지에 문자열과 바이너리 버퍼를 사용할 수 있기 때문에 라이브러리의 사용자가 데이터의 인코딩이나 사용자 지정 형식을 구현해야 한다.<br>
다음 예제에서 ZMQ소켓을 통과하는 데이터의 전처리 및 후처리를 추상화하는 미들웨어 인프라를 구축해본다.<br>
이를 통해 JSON 객체로 투명하게 작업을 수 있을 뿐만 아니라 처리 절차에 따라 이동하는 메시지를 완벽하게 압축할 수 있다.<br>
이러한 이유로 ZMQ는 종종 복잡한 분산 시스템을 구축하기 위해 사용돤다.</p>
<blockquote>
<p>zmqMiddlewareManager.js<br>
jsonMiddleware.js<br>
zmq_server.js<br>
ØMQ 라이브러리 설치 문제로 포기~~</p>
</blockquote>
<h2 id="koa에서-제너레이터를-사용한-미들웨어">6.9.4 Koa에서 제너레이터를 사용한 미들웨어</h2>
<p>미들웨어 패턴은 웹 프레임워크에서 데이터가 어플리케이션의 핵심을 통과하여 흐를 때 입력과 출력을 다룰 수 있는 논리적인 "계층"을 구축하는 유용한 메커니즘으로 실제로 유용함을 알 수 있었다.<br>
Express외에도 미들웨어 패턴을 많이 사용하는 다른 웹 프레임워크로 Koa가 있다.<br>
Koa는 콜백을 사용하는 대신, Es2015 제너레이터 함수를 사용하는 미들웨어 패턴을 구현한다.</p>
<blockquote>
<p>Koa는 제너레이터 패턴을 v3에서 Async로 바꿀 예정이다.</p>
</blockquote>
<p>Koa 웹 프레임워크 패턴에서, 우리 앱의 핵심(core)에 도달하기 전에 여러 가지 미들웨어를 가로지르는 요청(request)를 받았다. 이 부분의 화살표 흐름을 <strong>인바운드</strong> 또는 <strong>다운스트림</strong>이라고 한다.<br>
이 흐름이 앱의 핵심에 도달하면 모든 미들웨어를 다시 거쳐가게 되지만 이번에는 <strong>역순</strong>으로 수행한다.<br>
이것은 미들웨어가 앱의 메인 로직이 실행된 후 응답이 사용자에게 전송될 준비가 된 다음에, 또 다른 액션들을 수행할 수 있게 한다.<br>
화살표 흐름의 이 부분을 <strong>아웃바운드</strong> 또는 <strong>업스트림(Upstream)</strong> 이라고 한다.</p>
<blockquote>
<p>app.js<br>
rateLimit.js</p>
</blockquote>
<blockquote>
<p>coa의 제너레이터 패턴은 이제 Deprecate될 예정이므로, 제너레이터/yield 패턴을 async/await패턴으로 바꾸는 법을 연습해둬야 한다!</p>
</blockquote>
<h1 id="커맨드command">6.10 커맨드(Command)</h1>
<p>노드에서 중요한 다른 디자인 패턴이 커맨드(Command)이다.<br>
가장 일반적인 정의로, 커맨드는 <strong>나중에 수행할 동작에 필요한 모든 정보를 캡슐화하는 객체</strong>로 생각할 수 있다.<br>
따라서 메소드나 함수를 직접 호출하는 대신, 그러한 호출을 수행할 목적을 나타내는 <strong>객체를 생성</strong>한다. 그런 다음 이 목적을 <strong>구체화</strong>하여 실제 수행으로 전환시키는 것은 다른 컴포넌트의 책임이다.<br>
커맨드 패턴의 일반적인 구성은 다음과 같다.</p>
<ul>
<li>커맨드 : 메소드 또는 함수를 호출하는 데 필요한 정보를 캡슐화하는 객체</li>
<li>클라이언트 : 명령을 생성하고 호출자에게 제공</li>
<li>호출자 : 대상(Subject)에서 명령을 실행</li>
<li>타켓 : 호출자의 대상이다. 단일 함수거나, 한 객체의 메소드일 수 있다.</li>
</ul>
<p>이 네 가지 구성 요소는 패턴을 구현하는 방식에 따라 크게 달라질 수 있다.</p>
<p>직접 연산을 실행하는 것 대신 커멘드 패턴을 사용하면 다음과 같은 장점이 있다.<br>
어플리케이션에서 다음과 같은 작업을 할 수 있다.</p>
<ul>
<li>커맨드(Command)를 나중에 실행하도록 예약할 수 있다.</li>
<li>커맨드는 쉽게 직렬화되어 네트워크를 통해 전송될 수 있다. 이 간단한 속성을 사용하여 원격 컴퓨터 간에 작업을 배포하고, 브라우저에서 서버로 명령을 전송하고, RPC 시스템을 만드는 등의 작업을 수행할 수 있다.</li>
<li>커맨드를 사용하면 시스템에서 실행되는 모든 작업의 내역을 쉽게 유지할 수 있다.</li>
<li>커맨드는 데이터 동기화 및 충돌 해결을 위한 일부 알고리즘에서 중요한 부분이다.</li>
<li>실행이 예정된 커멘드가 아직 실행되지 않은 경우 취소할 수 있다.(실행 취소)</li>
<li>몇 가지 명령들을 그룹화할 수 있다. 이것은 원자성을 가진 트랜잭션을 만들거나 그룹의 모든 작업을 한번에 실행하는 매커니즘을 구현하는데 사용할 수 있다.</li>
<li>중복 제거, 결합 및 분할 혹은 오늘날의 실시간 협업 소프트웨어(공동 텍스트 편집 같은)기반인 **운영 변환(Operational Transform: OT)**과 같은 더 복잡한 알고리즘을 만드는 일련의 커맨드들로 다양한 종류의 변환을 수행할 수 있다.</li>
</ul>
<h2 id="유연한-패턴">6.10.1 유연한 패턴</h2>
<p>자바스크립트의 커맨드 패턴은 다양한 방법으로 구현될 수 있다.</p>
<h3 id="작업-패턴task-pattern">작업 패턴(Task Pattern)</h3>
<p>자바스크립트에서 호출을 표현하는 객체를 만드는 가장 쉬운 방법은 클로저를 만드는 것이다.</p>
<pre><code>function createTask(target, args){
	return ()=&gt;{
		target.apply(null,args);
	}
}
</code></pre>
<p>이 기술을 사용하면 별도의 컴포넌트를 사용하여 작업 실행을 제어하고 예약할 수 있다.<br>
이는 본질적으로 커맨드 패턴의 호출자와 같다.<br>
제너레이터와 함께 썽크를 사용했던것을 생각하면, 콜백 패턴 자체는 매우 간단한 커맨드 패턴의 버전이라고 생각할 수 있다.</p>
<h2 id="보다-복잡한-명령">6.10.2 보다 복잡한 명령</h2>
<p>이제 보다 복잡한 커맨드의 예를 살펴보자. 실행 취소 및 직렬화를 지원한다.</p>
<blockquote>
<p>command.js<br>
commandTest.js</p>
</blockquote>
<p>커맨드 패턴의 전체에서 실제로 필요한 것은 단순한 명령 실행이 다가 아니다.<br>
실제로 statusUpdateService 메소드를 호출하기 위해 얼마나 많은 코드를 작성해야 하는지 확인했다. 우리가 필요로 하는 모든 것이 단순히 호출일 뿐이라면 복잡한 커맨드는 오히려 해가 된다.<br>
작업의 실행을 취소, 예약해야 하는 경우, 혹은 비동기 작업을 실행해야 하는 경우에는 간단한 task 패턴이 최상의 절충안을 제공할 것이다.<br>
대신 이전에 설명한 실행 취소, 변환, 충돌 해결 같은 고급 기능이 필요한 경우에는 보다 복잡한 표현들을 가지는 커맨드 패턴의 사용이 필수적일 것이다.</p>
<h1 id="요약">6.11 요약</h1>
<p>전통적인 GoF디자인 패턴 중 일부를 자바스크립트, 특히 Node.js식으로 적용하는 방법을 배웠다. 그들 중 일부는 변형되었고, 일부는 단순화되었고, 다른 일부는 언어, 플랫폼 및 커뮤니티에 의해 그 일부로 동화되어 채택되거나 새로운 이름으로 변경되었다.</p>
<p>팩토리와 같은 간단한 패턴이 코드의 유연성을 얼마나 크게 향상시킬 수 있는지에 대해 프록시(Proxy), 데코레이터(Decorator) 및 어댑터(Adapter)를 사용하여 기존 객체의 인터페이스를 조작, 확장 및 조정할 수 있는 방법을 설명했다.<br>
전략(Startegy), 상태(State) 및 템플릿(Template)은 거대안 알고리즘을 정적(Static) 및 가변(variable) 파트로 분할하여 코드 및 재사용 컴포넌트의 확장성을 향상시키는 방법을 보여주었다.<br>
미들웨어(Middleware)패턴을 학습하여 간단하고 확장 가능하며 세련된 패러다임을 사용하여 데이터를 처리할 수 있게 되었다. 마지막으로 커맨드(Command)패턴은 모든 작업을 보다 강력하고 유연하게 만드는 간단한 추상화를 제공하였다.</p>
<p>이렇게 널리 받아들여지는 디자인 패턴의 자바스크립트를 통한 재탄생을 관찰하는 것 외에도 생성자 노출(revealing constructor) 및 합성 가능한 팩토리(Composable factory) 함수 패턴과 같이 자바스크립트 커뮤니티에서 특별히 생성되고 제시된 몇 가지 새로운 디자인 패턴을 볼 수 있었다.<br>
이러한 패턴은 비동기 및 프로토타입 기반 프로그래밍과 같은 자바스크립트 언어의 특정 측면을 다르는데 도움이 된다.<br>
마지막으로 자바스크립트로 더 많은 일들을 처리할 수 있다는 확신을 가질 수 있었고, 많은 작은 클래스나 인터페이스를 확장하는 대신 다른 재사용 가능한 객체 또는 함수를 작성하여 소프트웨어를 작성할 수 있음을 알게 되었다.</p>
<p>자바스크립트는 실용적인 언어이기 때문에, 어떤 구조나 지침도 없이 신속하게 일을 처리할 수 있다. 그래서 하나의 객체지향 패턴에 대한 구현 방식이 다양하기도 하다. 바로 그 점이 이 디자인 패턴을 유용하게 만든다.<br>
디자인 패턴을 적용할 때 유의할 점은, 창조성과 엄격함 사이의 올바른 균형적인 감각을 주고자 노력해야 한다는 것이다.<br>
정말로 중요한 것은, 전체의 큰 그림, 지침 및 패턴의 기반에 깔려있는 개념이다.<br>
이것은 우리가 노드 어플레케이션을 디자인할 수 있는 실제로 재사용 가능한 정보 중 하나이다.</p>

