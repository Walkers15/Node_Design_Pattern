---


---

<h1 id="장-node.js-필수-패턴">2장 Node.js 필수 패턴</h1>
<p>동기식 프로그래밍에서는 특정 문제를 해결하기 위해 연속적인 단계로 코드를 생각하게 된다. 즉 모든 작업이 블로킹이므로, 현재 작업이 완료될 때까지 기다린 후에 다음 작업을 실행할 수 있다.</p>
<p>비동기식으로 작업을 처리하면, 앞에서 요청한 작업의 종료 여부와 관계없이 그 다음 작업을 시작한다. 대신 백그라운드에서 실행중인 작업은 언제든지 완료될 수 있으며, 비동기 호출이 완료되면 적절한 방식으로 반응하도록 프로그래밍해야 한다.<br>
이러한 논-블로킹(작업의 완료를 기다리지 않음) 방식은 항상 우수한 성능을 가지지만, 복잡한 제어 흐름이 필요한 애플리케이션에서는 설계하기 까다로움.</p>
<p>이를 위해 Node.js에서는 <strong>콜백</strong> 과 <strong>이벤트 이미터</strong> 라는 두 가지 비동기 패턴을 사용함.</p>
<h2 id="콜백-패턴">2.1 콜백 패턴</h2>
<p>리액터 패턴 핸들러의 구현<br>
<strong>작업 결과를 전달</strong>하기 위해 호출. 비동기 작업을 위해 필수!<br>
자바스크립트에서는 함수가 일급 클래스 객체이므로, 변수에 할당하거나 인자로 전달하고, 다른 함수 호출에서 반환하거나 자료구조에 저장할 수 있기 때문에, 콜백을 쉽게 표현할 수 있다.</p>
<p>콜백을 구현하는 또 다른 이상적인 구조는 <strong>클로저</strong>이다.<br>
클로저를 사용하면 실제로 함수가 작성된 환경을 참조할 수 있다.<br>
콜백이 언제 어디서 호출되는 지에 관계없이 비동기 작업이 요청된 컨텍스트를 항상 유지할 수 있기 때문이다.</p>
<h3 id="연속-전달-방식">연속 전달 방식</h3>
<p>JS에서 콜백은 다른 함수에 <strong>인수로 전달되는 함수</strong>이며, 작업이 완료되면 결과로 호출된다.<br>
함수형 프로그래밍에서 결과를 전달하는 이러한 방식을 연속 전달 방식(The Continuation-passing Style,CPS)라고 한다.</p>
<h4 id="동기식-연속-전달-방식">동기식 연속 전달 방식</h4>
<pre><code>function add(a, b){
	return a + b;
}
</code></pre>
<p>return문을 이용해 호출자에 결과를 전달하는 방식을 **직접 스타일(Direct Style)**라고 하며, 동기화 프로그래밍에서 일반적으로 결과를 반환하는 방식이다.</p>
<p>이를 연속 전달 방식으로 바꾸면 다음과 같다.</p>
<pre><code>function add(a, b, callback){
	callback(a+b);
}
</code></pre>
<p>add()함수는 동기화된 CPS 함수로, 콜백이 완료될 때만 값을 반환한다.</p>
<pre><code>print("전")
add(1, 2, result =&gt; print("결과 :",result))
print("후")
//결과
전
3
후
</code></pre>
<p>아래와 같이 비동기식으로 작성하면, 결과는 다음과 같다.</p>
<pre><code>function addAsync(a, b, callback){
	setTimeout(() =&gt; callback(a+b),100);
}
//결과
전
후
3
</code></pre>
<p>비동기 작업이 완료되면 실행은 비동기 함수에 제공된 콜백에서부터 다시 실행된다.<br>
실행은 <strong>이벤트 루프</strong>에서 시작되기 때문에 새로운 스택을 가진다.<br>
<strong>클로저</strong> 덕분에 콜백이 다른 시점과 다른 위치에서 호출되더라도, 비동기 함수의 호출자 컨텍스트를 유지할 수 있다.</p>
<h4 id="비-연속-전달-방식의-콜백">비 연속 전달 방식의 콜백</h4>
<p>함수에 콜백 인자가 있어도, 함수가 비동기식나 연속 전달 스타일이 아닐 수 있다.</p>
<pre><code>const result = [1, 5, 7].map(element =&gt; element -1);
console.log(result);
</code></pre>
<p>위 구문에서, 콜백은 단지 배열 내의 요소를 반복하는데 사용될 뿐, 연산 결과를 전달하지 않는다.</p>
<h3 id="동기냐-비동기냐">동기냐 비동기냐?</h3>
<p>가장 위험한 상황 중 하나는 조건문 등으로 분기 처리한 블록이 하나는 동기식이고 하나는 비동기식인 경우다.</p>
<p>캐싱되어 있는 파일과 그렇지 않은 파일을 읽는 프로그램이 있다고 가정했을 때, 파일을 읽는 함수가 결과를 반환할때까지 캐시가 결정되지 않은 경우 비동기식으로 작동한다. 하지만 캐시가 이미 있는 파일에 대한 모든 후속 요청에 대해서는 동기식으로 변해 즉각적으로 콜백을 호출하므로 위험하다.</p>
<p>이렇게 동기 / 비동기식이 혼용될 가능성이 있는 프로그램을 짜는 것을 Zalgo를 풀어놓는다고 한다.</p>
<h4 id="동기-api의-사용">동기 API의 사용</h4>
<p>Zalgo의 사례에서 알 수 있는 교훈은, API의 동기 또는 비동기 특성을 명확하게 정의하는 것이 필수적이라는 것이다.</p>
<p>동기 API를 사용하면, 혼란이 줄어들고 성능 측면에서 보다 효율적일 수 있다.<br>
하지만 동기 API를 반복적으로 사용할 경우, JS의 동시성 모델을 깨뜨리므로 전체 어플리케이션의 속도를 떨어뜨릴 수 있다.<br>
따라서, <strong>어플리케이션이 동시 요청을 처리하는 데 영향을 주지 않는 경우에만 블로킹 API를 사용하여야 한다.</strong></p>
<h4 id="지연-실행">지연 실행</h4>
<p>API의 동기/비동기 혼용을 막기 위해서는 위에서처럼 전부 동기식으로 만드는 방법도 있지만, 완전히 비동기로 만드는 방법도 있다.</p>
<p>구문을 비동기식으로 만드는 트릭을 노드에서는 두 가지 정도를 제공한다.<br>
하나는 process.nextTick()을 사용하는 것이다.</p>
<pre><code>process.nextTick(() =&gt; callback(cache[filename]));
</code></pre>
<p>process.nextTick()은 이벤트 루프의 다음 사이클까지 함수의 실행을 지연시킨다. 즉, 콜백을 인수로 취하여, 대기 중인 I/O이벤트의 ** 맨 앞** 으로 밀어 놓고 즉시 반환한다. 그러면 콜백은 이벤트 루프가 다시 실행되는 즉시 호출된다.</p>
<p>또 다른 방법은, setImmediate()를 사용하는 것이다. setImmediate()는 이미 큐에 있는 다른 I/O이벤트들의 <strong>맨 뒤</strong>에 콜백을 대기시킨다.</p>
<h3 id="node.js-콜백-규칙">Node.js 콜백 규칙</h3>
<p>코어 및 대부분의 사용자 정의 모듈 및 앱에 적용되는 비동기 API 규칙이 있다.</p>
<p>** 콜백을 맨 마지막에**</p>
<pre><code>fs.readFile(filename,[options],callback);
</code></pre>
<p>다른 옵션이 있더라도, 콜백은 항상 마지막 위치에 놓아야 한다.<br>
이 규칙의 이유는 콜백이 적절한 위치에 정의되어 있는 경우, 함수 호출의 가독성이 더 좋기 때문이다.</p>
<p><strong>오류는 맨 앞에</strong><br>
연속 전달 스타일(CPS)에서는 오류가 다른 유형의 결과처럼 제공되므로, 콜백 사용이 필요하다. 노드에서 CPS함수에 의해 생성된 오류는 항상 콜백의 첫 번째 인수로 전달되며, 실제 결과는 두 번째 인수에서부터 전달된다.<br>
동작이 에러 없이 성공하면, 첫 번째 인수는 null 혹은 undefined이다.</p>
<pre><code>fs.readFile('foo.txt','utf8',(err,data)=&gt;{
	if(err){
		errorhandler(err);
	} else {
		processData(data);
	}
});
</code></pre>
<p>에러가 있는지 항상 체크하는 것이 좋다.<br>
<strong>오류 전파</strong><br>
동기식 직접 스타일 함수의 오류 전파는 throw문을 사용하여 수행되므로, 오류가 catch될 때까지 호출 스택에서 실행된다.</p>
<p>하지만 비동기식 CPS 에서, 적절한 오류 전달은 오류를 호출 체인의 다음에서 콜백으로 전달하여 수행된다.</p>
<pre><code>const fs = require('fs');
function readJSON(filename, callback){
	fs.readFIle(filename,'utf8',(err, data)=&gt;{
		let parsed;
		if(err){
			return callback(err)
		}
		try{
			parsed = JSON.parse(data);
		} catch(err){
			return callback(err);
		}
		callback(null,parsed);
	});
};
</code></pre>
<p>유효한 결과를 전달할 때 첫 번째 인자는 null이다.<br>
또한, 에러를 전파할 때 <strong>return</strong>을 사용한다.<br>
콜백 함수가 호출되는 즉시 함수에서 빠져 나와 그 다음 줄이 실행되지 않는다.</p>
<p><strong>캐치되지 않는 예외</strong><br>
노드에서는 캐치되지 않는 에러에 대해 uncaughtException이라는 특수 이벤트를 내보낸다.<br>
캐치되지 않은 예외가 어플리케이션의 일관성을 보장할 수 없는 상태로 만든다.<br>
이로 인해 예기치 않은 문제가 발생할 수 있다.<br>
따라서, 잡히지 않은 예외가 수딘되면 항상 어플리케이션을 종료하는 것이 중요하다.</p>
<h2 id="모듈-시스템과-그-패턴">2.2 모듈 시스템과 그 패턴</h2>
<p>모듈은 복잡한 어플리케이션을 구성하기 위한 블록 역할을 하기도 하지만, 명시적으로 익스포트 표시되지 않은 모든 내부적인 함수와 변수들을 비공개로 유지하며 정보를 숨기는 중요한 매커니즘이기도 하다.</p>
<h3 id="노출식-모듈-패턴">노출식 모듈 패턴</h3>
<p>JS의 주요 문제점 중 하나가 네임스페이스가 없다는 점이다.<br>
전역 범위에서 실행되는 프로그램은 내부 어플리케이션과 종속된 라이브러리 코드의 데이터들로 인해 충돌이 발생할 수 있다.<br>
이를 해결하기 위한 보편적인 기법을, 노출식 모듈 패턴이라고 한다.</p>
<pre><code>const module = (()=&gt;{
	const privateFoo = () =&gt; { ... };
	const privateBar = [];
	
	const exported = {
		publicFoo: () =&gt; { ... },
		publicBar: () =&gt; { ... }
	};
	return exported;
})();
console.log(module);
</code></pre>
<p>위 패턴은 자기 호출 함수를 사용하여 private 범위를 만들고, 공개될 부분만 익스포트한다. console.log로 출력하는 변수는 exported된 API만 포함하고 있으며, 나머지 모듈 내부의 콘텐츠는 실제로 외부에서 액세스할 수 없다.</p>
<h3 id="node.js-모듈-설명">Node.js 모듈 설명</h3>

