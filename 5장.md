---


---

<h1 id="장-스트림-코딩">5장 스트림 코딩</h1>
<p>스트림은 노드의 가장 중요한 컴포넌트이자 패턴중 하나이다.</p>
<h2 id="스트림의-중요성">5.1 스트림의 중요성</h2>
<p>이벤트 기반 플랫폼에서 I/O를 처리하는 가장 효율적인 방법은, 실시간으로 가능한 순간 바로 입력을 사용하고 어플리케이션에서 출력이 생성되는 즉시 내보내는 것이다.</p>
<h3 id="버퍼링-대-스트리밍">버퍼링 대 스트리밍</h3>
<p>fs.readFile 등 거의 모든 비동기 API는 버퍼 모드를 사용한다.<br>
입력 조작의 경우 버퍼 모드는 리소스로부터 오는 모든 데이터를 버퍼에 수집한다.<br>
그리고 자원을 모두 읽어들인 후 콜백에 전달한다.<br>
버퍼의 문제점은, I/O동작이 <strong>완료</strong>될 때 까지 기다려야 한다는 점이다.<br>
반면에 스트림을 사용하면, 리소스에서 도착하자마자 데이터를 처리할 수 있다.<br>
소비자는 이제 모든 데이터가 버퍼에 수집될 때까지 기다리지 않고 즉시 처리할 수 있다.<br>
이 두 방식은 <strong>공간 효율성</strong> 과 <strong>시간 효율성</strong> 에서 차이를 보인다. 또한 <strong>결합성</strong>에서도 차이를 보인다.</p>
<h3 id="공간-효율성">공간 효율성</h3>
<p>스트림은 버퍼처럼 모든 데이터를 한꺼번에 처리하지 않으므로, 버퍼에서는 불가능했던 수백 메가, 혹은 기가바이트의 매우 큰 파일을 읽는 등의 작업도 가능하게 된다.</p>
<h4 id="버퍼링된-api를-사용한-압축">버퍼링된 API를 사용한 압축</h4>
<p>간단한 CLI를 생각해 보자.</p>
<pre><code>const fs = require('fs');
const zlib = require('zlib');
const file = process.argv[2];

fs.readFile(file,(err. buffer) =&gt; {
   zlib.gzib(buffer,(err, buffer)-&gt;{
   	fs.writeFile(file + '.gz', buffer, err=&gt;{
   		console.log('File sucessfully compressed');
   	});
   });
});

##실행
node gzip &lt;filepath&gt;
</code></pre>
<p>V8의 버퍼는 약 1기가이므로, 그것보다 더 큰 파일을 제공하면 오류가 발생한다.</p>
<h4 id="스트림을-사용한-압축">스트림을 사용한 압축</h4>
<p>앞의 예시와 달리, 스트림을 이용하면 크기가 큰 파일도 압축할 수 있다.</p>
<pre><code> const fs = require('fs');
 const zlib = require('zilb');
const file = process.argv[2];

fs.createReadStream(file)
	.pipe(zlib.createGzip())
	.pipe(fs.createWritreStream(file + '.gz'))
	.on('finish', () =&gt; console.log('File successfully compressed'));
</code></pre>
<p>스트림은 성능뿐만 아니라 인터페이스도 좋고, 결합성이 뛰어나다.<br>
따라서 깨끗하고 우아하며 간결한 코드의 작성이 가능하다.</p>
<h3 id="시간-효율성">시간 효율성</h3>
<p>파일을 압축하고 원격 HTTP 서버에 업로드하는 어플리케이션이 있을 때, 원격 HTTP서버는 압축을 풀어 파일 시스템에 저장한다. 이 때 클라이언트가 버퍼링 API를 사용하여 구현하면, 업로드는 전체 파일을 읽어 압축한 경우에만 시작할 수 있다. 똑같은 결과를 얻는 데 더 좋은 방법은 <strong>스트림</strong>을 사용하는 것이다. 클라이언트 시스템에서 스트림을 사용하면, 파일 시스템에서 데이터 덩어리를 읽는 즉시 압측하고 보낼 수 있다.<br>
반면 서버에서는 원격 피어에서 수신된 즉시 모든 덩어리를 압축 해제할 수 있다.</p>
<pre><code># 서버
const http = require('http');
const fs = require('fs');
const zlib = require('zlib');

const server = http.createServer((req,res)=&gt;{
	const filename = req.headers.filename;
	console.log('File request received: " + filename);
req
	.pipe(zlib.createGunzip())
	.pipe(fs.createWriteStream(filename))
	.on('finish',()=&gt;{
		res.writeHead(201, {'Content-Type': 'text/plain'});
		res.end('That's it\n');
		console.log(`File saved: ${filename}`);
	});
});

server.listen(3000,()=&gt;console.log('Listening'));
</code></pre>
<blockquote>
<p>D:\NodeJS\DesignPattern\gzipReceive.js<br>
D:\NodeJS\DesignPattern\gzipSend.js</p>
</blockquote>
<p>앞서 말했듯 버퍼를 사용하면, 데이터가 다 올 때 까지 기다린 다음 압축을 시작한다. 이것은 완전히 순차적이다.</p>
<p>하지만 스트림을 사용하면, 첫 청크가 수신되자마자 조립 라인이 시작된다.<br>
또 놀라운 것은, 다음 청크가 사용 가능한 상태가 되면 조립 라인이 병렬로 시작된다.</p>
<h3 id="결합성">결합성</h3>
<p>위의 예시에서 서로 다른 프로세스 유닛들이 pipe()메소드를 사용하여 어떻게 스트림을 구성하는지에 대해 확인했다.<br>
이는 스트림이 균일한 인터페이스를 가지며, API 측면에서 서로를 이해할 수 있기 때문이다. 유일한 전제 조건은 파이프라인의 다음 스트림이 이전 스트림에 의해 생성되어 전달된 데이터 타입을 지원해야 한다는 것이다.<br>
이 데이터 타입은 바이너리, 텍스트, 또는 객체가 될 수 있다.</p>
<p>이 속성(결합성 - pipe의 메소드가 균일함)의 또 다른 예로 암호화를 살펴보자.<br>
위의 모듈에 다음과 같이 암호화 메소드를 추가한다.</p>
<pre><code>#서버
const crypto = require('crypto');
...
	.pipe(zlib.createGzip())
	.pipe(crypto.createCipher('aes-256-cbc','password'))
	...
</code></pre>
<pre><code>#클라
const crypto = require('crypto');
...
res
	.pipe(crypto.createDecipher('aes-256-cbc','password'))
	...
</code></pre>
<p>우리는 이미 존재하는 파이프라인에 변환 스트림을 끼워 넣어 스트림을 재사용했다. 비슷한 방식으로 다른 스트림을 추가하여 결합할 수 있다.</p>
<p>이 접근법의 주요 방법은 재사용성이지만, 지금까지 제시한 코드에서 알 수 있듯 스트림을 사용하면 더 깨끗하고 모듈화된 코드를 만들 수 있다.<br>
이러한 이유로 스트림은 순수한 I/O를 다루는 것뿐만 아니라 코드를 단순화하고 모듈화하는 수단으로 사용되기도 한다.</p>

